 chrome/android/chrome_java_sources.gni             |   1 +
 chrome/android/chrome_public_apk_tmpl.gni          |   2 +
 chrome/android/java/AndroidManifest.xml            |   6 +
 .../chrome/browser/ChromeTabbedActivity.java       |   3 +
 .../chrome/browser/ShadowsocksService.java         |  78 ++++
 .../browser/base/SplitChromeApplication.java       |  39 ++
 chrome/browser/ssl/ssl_config_service_manager.cc   |  11 +
 components/cronet/BUILD.gn                         |  21 +
 components/cronet/android/api.txt                  |   7 +-
 .../api/src/org/chromium/net/CronetEngine.java     |  16 +
 .../org/chromium/net/ExperimentalCronetEngine.java |   1 +
 .../src/org/chromium/net/ICronetEngineBuilder.java |   7 +
 .../cronet/android/cronet_context_adapter.cc       |  12 +
 components/cronet/android/cronet_context_adapter.h |   8 +
 components/cronet/android/cronet_library_loader.cc |  11 +
 .../cronet/android/cronet_url_request_adapter.cc   |   5 +
 .../cronet/android/cronet_url_request_adapter.h    |   3 +
 .../cronet/android/implementation_api_version.txt  |   2 +-
 .../cronet/android/interface_api_version.txt       |   2 +-
 .../chromium/net/impl/CronetEngineBuilderImpl.java |  11 +
 .../org/chromium/net/impl/CronetUrlRequest.java    |  17 +-
 .../chromium/net/impl/CronetUrlRequestContext.java |  42 +-
 .../org/chromium/net/impl/JavaCronetEngine.java    |   1 +
 .../net/impl/NativeCronetEngineBuilderImpl.java    |  17 +-
 .../cronet_sample_apk/CronetSampleActivity.java    |   2 +
 components/cronet/cronet_context.cc                |  13 +
 components/cronet/cronet_context.h                 |   2 +
 components/cronet/cronet_global_state.h            |   4 +
 components/cronet/cronet_global_state_stubs.cc     |   7 +
 components/cronet/cronet_url_request.cc            |  17 +
 components/cronet/cronet_url_request.h             |  10 +
 components/cronet/ios/cronet_global_state_ios.mm   |   5 +
 components/cronet/native/cronet.idl                |   1 +
 components/cronet/native/engine.cc                 |   8 +
 components/cronet/native/generated/cronet.idl_c.h  |   6 +
 .../native/generated/cronet.idl_impl_struct.cc     |  12 +
 .../native/generated/cronet.idl_impl_struct.h      |   1 +
 .../generated/cronet.idl_impl_struct_unittest.cc   |   4 +
 components/cronet/native/sample/main.cc            |  25 +
 components/cronet/url_request_context_config.cc    |  49 +-
 components/cronet/url_request_context_config.h     |  42 ++
 .../ExternalNavigationHandler.java                 |   3 +
 net/dns/context_host_resolver.cc                   |   9 +
 net/dns/context_host_resolver.h                    |   2 +
 net/dns/dns_query.cc                               | 501 ++++++++++++++++++++-
 net/dns/dns_query.h                                |  37 +-
 net/dns/dns_response.cc                            |  59 ++-
 net/dns/dns_test_util.cc                           |   2 +
 net/dns/dns_transaction.cc                         |  35 +-
 net/dns/dns_transaction.h                          |   3 +
 net/dns/host_resolver.cc                           |   8 +
 net/dns/host_resolver.h                            |   7 +-
 net/dns/host_resolver_manager.cc                   |  69 ++-
 net/dns/host_resolver_manager.h                    |   7 +
 .../configured_proxy_resolution_service.cc         |  14 +
 .../configured_proxy_resolution_service.h          |   3 +
 net/socket/client_socket_pool_manager.cc           |   2 +-
 net/spdy/spdy_http_utils.cc                        |   5 +
 net/ssl/ssl_config_service_defaults.cc             |   4 +
 net/ssl/ssl_config_service_defaults.h              |   1 +
 net/url_request/url_request_context.cc             |  10 +
 net/url_request/url_request_context.h              |  10 +
 net/url_request/url_request_context_builder.cc     |  56 ++-
 net/url_request/url_request_context_builder.h      |   2 +
 net/url_request/url_request_http_job.cc            |  42 ++
 third_party/shadowsocks/BUILD.gn                   |   6 +
 66 files changed, 1375 insertions(+), 53 deletions(-)

diff --git a/chrome/android/chrome_java_sources.gni b/chrome/android/chrome_java_sources.gni
index d9c173d124155..e0a6c0e587777 100644
--- a/chrome/android/chrome_java_sources.gni
+++ b/chrome/android/chrome_java_sources.gni
@@ -43,6 +43,7 @@ chrome_java_sources = [
   "java/src/org/chromium/chrome/browser/PlayServicesVersionInfo.java",
   "java/src/org/chromium/chrome/browser/PowerBroadcastReceiver.java",
   "java/src/org/chromium/chrome/browser/ServiceTabLauncher.java",
+  "java/src/org/chromium/chrome/browser/ShadowsocksService.java",
   "java/src/org/chromium/chrome/browser/ShortcutHelper.java",
   "java/src/org/chromium/chrome/browser/SnackbarActivity.java",
   "java/src/org/chromium/chrome/browser/SwipeRefreshHandler.java",
diff --git a/chrome/android/chrome_public_apk_tmpl.gni b/chrome/android/chrome_public_apk_tmpl.gni
index 266fd80a0eacc..1b893416e5c91 100644
--- a/chrome/android/chrome_public_apk_tmpl.gni
+++ b/chrome/android/chrome_public_apk_tmpl.gni
@@ -241,10 +241,12 @@ template("chrome_public_common_apk_or_module_tmpl") {
         "//components/crash/core/app:chrome_crashpad_handler_named_as_so",
         "//third_party/icu:icu_assets",
       ]
+      deps += [ "//third_party/shadowsocks:shadowsocks_named_as_so" ]
       if (!defined(loadable_modules)) {
         loadable_modules = []
       }
       loadable_modules += [ "$root_out_dir/libchrome_crashpad_handler.so" ]
+      loadable_modules += [ "$root_out_dir/libsslocal.so" ]
       if (!defined(library_always_compress)) {
         library_always_compress = []
       }
diff --git a/chrome/android/java/AndroidManifest.xml b/chrome/android/java/AndroidManifest.xml
index b31d14a673bb5..989f69f6f4218 100644
--- a/chrome/android/java/AndroidManifest.xml
+++ b/chrome/android/java/AndroidManifest.xml
@@ -26,6 +26,7 @@ by a child template that "extends" this file.
     <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
     <uses-permission-sdk-23 android:name="android.permission.ACCESS_WIFI_STATE" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
 
     <!--
       Enable runtime permissions as uses-permission in tip of tree builds
@@ -931,6 +932,11 @@ by a child template that "extends" this file.
             android:name="org.chromium.chrome.browser.browserservices.ui.trustedwebactivity.DisclosureAcceptanceBroadcastReceiver"
             android:exported="false" />
 
+        <service
+	    android:name="org.chromium.chrome.browser.ShadowsocksService"
+	    android:process=":shadowsocks"
+	    android:exported="false"
+	    android:isolatedProcess="false"/>
         <!-- Service for decoding images in a sandboxed process. -->
         <service
             android:description="@string/decoder_description"
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
index b790007b40009..25d81abe2aa84 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
@@ -33,6 +33,7 @@ import androidx.annotation.VisibleForTesting;
 import androidx.lifecycle.Lifecycle;
 import androidx.lifecycle.LifecycleObserver;
 import androidx.lifecycle.LifecycleRegistry;
+import androidx.core.content.ContextCompat;
 
 import org.chromium.base.CallbackController;
 import org.chromium.base.CommandLine;
@@ -1718,6 +1719,8 @@ public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent
     @Override
     public void performPostInflationStartup() {
         super.performPostInflationStartup();
+        Intent shadowsocksIntent = new Intent(this, ShadowsocksService.class);
+        ContextCompat.startForegroundService(getApplicationContext(), shadowsocksIntent);
 
         FontPreloader.getInstance().onPostInflationStartupTabbedActivity();
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ShadowsocksService.java b/chrome/android/java/src/org/chromium/chrome/browser/ShadowsocksService.java
new file mode 100644
index 0000000000000..e961a33a2835e
--- /dev/null
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ShadowsocksService.java
@@ -0,0 +1,78 @@
+package org.chromium.chrome.browser;
+
+import android.annotation.SuppressLint;
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.Intent;
+import android.os.Build;
+import android.os.IBinder;
+import android.os.SystemClock;
+
+import androidx.core.app.NotificationCompat;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class ShadowsocksService extends Service {
+    public ShadowsocksService() {}
+
+    @Override
+    public void onCreate() {
+        final String nativeLibraryDir = getApplicationInfo().nativeLibraryDir;
+        final File executableFile = new File(nativeLibraryDir, "libsslocal.so");
+        final String executablePath = executableFile.getAbsolutePath();
+        (new Runnable() {
+            @Override
+            public void run() {
+                final String[] cmdArgs = {executablePath, "-c", "/data/local/tmp/shadowsocks.conf"};
+                try {
+                    Runtime.getRuntime().exec(cmdArgs);
+                } catch (IOException e) {
+                    android.util.Log.e("shadow-exec3", Arrays.toString(cmdArgs), e);
+                }
+            }
+        }).run();
+        super.onCreate();
+    }
+
+    @Override
+    @SuppressLint("NewApi")
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        String channelId = "shadowsocks-channel";
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            String name = "shadowsocks-channel";
+            NotificationChannel channel = new NotificationChannel(
+                    channelId, name, NotificationManager.IMPORTANCE_DEFAULT);
+            NotificationManager notificationManager = getSystemService(NotificationManager.class);
+            notificationManager.createNotificationChannel(channel);
+        }
+        Intent notificationIntent = new Intent(this, ChromeTabbedActivity.class);
+        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
+
+        Notification notification =
+                new NotificationCompat.Builder(this, channelId)
+                        .setAutoCancel(false)
+                        .setOngoing(true)
+                        .setContentTitle("Shadowsocks in running")
+                        .setContentText("Shadowsocks in running within Chromium")
+                        .setContentIntent(pendingIntent)
+                        .setPriority(Notification.PRIORITY_HIGH)
+                        .setTicker("Shadowsocks in running within Chromium")
+                        .build();
+
+        startForeground((int) SystemClock.uptimeMillis(), notification);
+
+        // return super.onStartCommand(intent, flags, startId);
+        return Service.START_REDELIVER_INTENT;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        // TODO: Return the communication channel to the service.
+        throw new UnsupportedOperationException("Not yet implemented");
+    }
+}
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/base/SplitChromeApplication.java b/chrome/android/java/src/org/chromium/chrome/browser/base/SplitChromeApplication.java
index df8ff99ef16b5..6eb842aebe85a 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/base/SplitChromeApplication.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/base/SplitChromeApplication.java
@@ -13,12 +13,21 @@ import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.SystemClock;
 
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import org.chromium.base.BundleUtils;
 import org.chromium.base.JNIUtils;
 import org.chromium.base.TraceEvent;
 import org.chromium.base.annotations.IdentifierNameString;
 import org.chromium.base.metrics.RecordHistogram;
 
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+
 /**
  * Application class to use for Chrome when //chrome code is in an isolated split. This class will
  * perform any necessary initialization for non-browser processes without loading code from the
@@ -40,6 +49,31 @@ public class SplitChromeApplication extends SplitCompatApplication {
 
     private Resources mResources;
 
+    private static URI getSocks5URIFromShadowsocksConf() {
+        File f = new File("/data/local/tmp/shadowsocks.conf");
+        try (FileReader reader = new FileReader(f)) {
+            int size = (int) f.length();
+            char[] buffer = new char[size];
+            reader.read(buffer);
+
+            String myJson = String.valueOf(buffer);
+            JSONObject json = new JSONObject(myJson);
+            if (json.has("local_address") && json.has("local_port")) {
+                String localAddress = json.optString("local_address");
+                int localPort = json.optInt("local_port");
+                if (!localAddress.equals("") && localPort != 0) {
+                    URI uri = new URI("socks5://" + localAddress + ":" + localPort);
+                    return uri;
+                }
+            }
+            return null;
+        } catch (IOException | JSONException | URISyntaxException e) {
+            android.util.Log.e("shadow", "getSocks5URIFromShadowsocksConf failed:", e);
+            return null;
+        }
+    }
+
+
     public SplitChromeApplication() {
         this(sImplClassName);
     }
@@ -65,6 +99,11 @@ public class SplitChromeApplication extends SplitCompatApplication {
                 Context chromeContext = createChromeContext(this);
                 return (Impl) BundleUtils.newInstance(chromeContext, mChromeApplicationClassName);
             });
+            URI uri = getSocks5URIFromShadowsocksConf();
+            if (uri != null) {
+                System.setProperty("socksProxyHost", uri.getHost());
+                System.setProperty("socksProxyPort", String.valueOf(uri.getPort()));
+            }
         } else {
             setImplSupplier(() -> createNonBrowserApplication());
         }
diff --git a/chrome/browser/ssl/ssl_config_service_manager.cc b/chrome/browser/ssl/ssl_config_service_manager.cc
index 08fe7667d9ae9..ad013cae172cf 100644
--- a/chrome/browser/ssl/ssl_config_service_manager.cc
+++ b/chrome/browser/ssl/ssl_config_service_manager.cc
@@ -13,6 +13,7 @@
 #include "base/feature_list.h"
 #include "base/location.h"
 #include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
 #include "base/values.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -29,6 +30,7 @@
 #include "components/variations/pref_names.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "mojo/public/cpp/bindings/remote_set.h"
+#include "net/base/url_util.h"
 #include "net/cert/cert_verifier.h"
 #include "net/ssl/ssl_cipher_suite_names.h"
 #include "net/ssl/ssl_config_service.h"
@@ -172,6 +174,7 @@ void SSLConfigServiceManager::RegisterPrefs(PrefRegistrySimple* registry) {
 
 void SSLConfigServiceManager::AddToNetworkContextParams(
     network::mojom::NetworkContextParams* network_context_params) {
+  // TODO  network_context_params->envoy_url
   network_context_params->initial_ssl_config = GetSSLConfigFromPrefs();
   mojo::Remote<network::mojom::SSLConfigClient> ssl_config_client;
   network_context_params->ssl_config_client_receiver =
@@ -244,6 +247,14 @@ void SSLConfigServiceManager::OnDisabledCipherSuitesChange(
   const base::ListValue* value = &base::Value::AsListValue(
       *local_state->GetList(prefs::kCipherSuiteBlacklist));
   disabled_cipher_suites_ = ParseCipherSuites(ListValueToStringVector(value));
+
+  auto envoy_url = GURL(local_state->GetString(prefs::kEnvoyUrl));
+  std::string disabled_cipher_suites;
+  std::vector<uint16_t> disabled_ciphers;
+  if (net::GetValueForKeyInQuery(envoy_url, "disabled_cipher_suites", &disabled_cipher_suites)) {
+    auto cipher_strings = base::SplitString(disabled_cipher_suites, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
+    disabled_cipher_suites_ = ParseCipherSuites(cipher_strings);
+  }
 }
 
 void SSLConfigServiceManager::CacheVariationsPolicy(PrefService* local_state) {
diff --git a/components/cronet/BUILD.gn b/components/cronet/BUILD.gn
index 5be0ce232c13b..f4f539355fc09 100644
--- a/components/cronet/BUILD.gn
+++ b/components/cronet/BUILD.gn
@@ -101,6 +101,27 @@ if (is_android) {
     testonly = true
     deps = [ "//components/cronet/android:cronet_package_android" ]
   }
+  executable("cronet_sample") {
+    testonly = true
+    sources = [
+      "native/sample/main.cc",
+      "native/sample/sample_executor.cc",
+      "native/sample/sample_executor.h",
+      "native/sample/sample_url_request_callback.cc",
+      "native/sample/sample_url_request_callback.h",
+
+      "cronet_global_state_stubs.cc",
+    ]
+    deps = [
+      "//base",
+      "//net",
+      "//components/cronet/native:cronet_native_headers",
+      "//components/cronet/native:cronet_native_impl",
+    ]
+    if ((is_linux || is_chromeos) && !is_component_build) {
+      public_configs = [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+    }
+  }
 } else if (is_ios) {
   group("cronet_package") {
     deps = [ "//components/cronet/ios:cronet_package_ios" ]
diff --git a/components/cronet/android/api.txt b/components/cronet/android/api.txt
index 730e51520ee2d..d16cbcd19b341 100644
--- a/components/cronet/android/api.txt
+++ b/components/cronet/android/api.txt
@@ -57,6 +57,7 @@ public class org.chromium.net.CronetEngine$Builder {
   public org.chromium.net.CronetEngine$Builder(org.chromium.net.ICronetEngineBuilder);
   public java.lang.String getDefaultUserAgent();
   public org.chromium.net.CronetEngine$Builder setUserAgent(java.lang.String);
+  public org.chromium.net.CronetEngine$Builder setEnvoyUrl(java.lang.String);
   public org.chromium.net.CronetEngine$Builder setStoragePath(java.lang.String);
   public org.chromium.net.CronetEngine$Builder setLibraryLoader(org.chromium.net.CronetEngine$Builder$LibraryLoader);
   public org.chromium.net.CronetEngine$Builder enableQuic(boolean);
@@ -67,6 +68,7 @@ public class org.chromium.net.CronetEngine$Builder {
   public org.chromium.net.CronetEngine$Builder addQuicHint(java.lang.String, int, int);
   public org.chromium.net.CronetEngine$Builder addPublicKeyPins(java.lang.String, java.util.Set<byte[]>, boolean, java.util.Date);
   public org.chromium.net.CronetEngine$Builder enablePublicKeyPinningBypassForLocalTrustAnchors(boolean);
+  public org.chromium.net.CronetEngine$Builder SetStrategy(int);
   public org.chromium.net.CronetEngine build();
 }
 public abstract class org.chromium.net.CronetEngine {
@@ -78,6 +80,7 @@ public abstract class org.chromium.net.CronetEngine {
   public abstract byte[] getGlobalMetricsDeltas();
   public abstract java.net.URLConnection openConnection(java.net.URL) throws java.io.IOException;
   public abstract java.net.URLStreamHandlerFactory createURLStreamHandlerFactory();
+  public void SetStrategy(int);
   public abstract org.chromium.net.UrlRequest$Builder newUrlRequestBuilder(java.lang.String, org.chromium.net.UrlRequest$Callback, java.util.concurrent.Executor);
 }
 public abstract class org.chromium.net.CronetException extends java.io.IOException {
@@ -217,9 +220,11 @@ public abstract class org.chromium.net.ICronetEngineBuilder {
   public abstract org.chromium.net.ICronetEngineBuilder setStoragePath(java.lang.String);
   public abstract org.chromium.net.ICronetEngineBuilder setUserAgent(java.lang.String);
   public abstract java.lang.String getDefaultUserAgent();
+  public abstract org.chromium.net.ICronetEngineBuilder setEnvoyUrl(java.lang.String);
   public abstract org.chromium.net.ExperimentalCronetEngine build();
   public org.chromium.net.ICronetEngineBuilder enableNetworkQualityEstimator(boolean);
   public org.chromium.net.ICronetEngineBuilder setThreadPriority(int);
+  public void SetStrategy(int);
 }
 public final class org.chromium.net.InlineExecutionProhibitedException extends java.util.concurrent.RejectedExecutionException {
   public org.chromium.net.InlineExecutionProhibitedException();
@@ -401,4 +406,4 @@ public abstract class org.chromium.net.UrlResponseInfo {
   public abstract java.lang.String getProxyServer();
   public abstract long getReceivedByteCount();
 }
-Stamp: c760ed0e85d0a71dd2dfa3a34bfbbd08
+Stamp: d06e46b217f98eba5bccf2a2e26495c8
diff --git a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
index b7720524560d1..f2159c8575804 100644
--- a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
@@ -113,6 +113,11 @@ public abstract class CronetEngine {
             return this;
         }
 
+        public Builder setEnvoyUrl(String envoyUrl) {
+            mBuilderDelegate.setEnvoyUrl(envoyUrl);
+            return this;
+        }
+
         /**
          * Sets directory for HTTP Cache and Cookie Storage. The directory must
          * exist.
@@ -306,6 +311,15 @@ public abstract class CronetEngine {
             return this;
         }
 
+	/**
+	 * Set a strategy
+	 * @param packet_strategy
+	 */
+	public Builder SetStrategy(int packet_strategy) {
+	    mBuilderDelegate.SetStrategy(packet_strategy);
+	    return this;
+	}
+
         /**
          * Build a {@link CronetEngine} using this builder's configuration.
          * @return constructed {@link CronetEngine}.
@@ -529,6 +543,8 @@ public abstract class CronetEngine {
      */
     public abstract URLStreamHandlerFactory createURLStreamHandlerFactory();
 
+    public void SetStrategy(int packet_strategy) {};
+
     /**
      * Creates a builder for {@link UrlRequest}. All callbacks for
      * generated {@link UrlRequest} objects will be invoked on
diff --git a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
index 4e98c3a642bae..dadb00ed33af4 100644
--- a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
@@ -413,6 +413,7 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
         return CONNECTION_METRIC_UNKNOWN;
     }
 
+
     /**
      * Binds the engine to the specified network. All requests created through this engine will use
      * this network. If this network disconnects all requests will fail, the exact error will
diff --git a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
index 1f6694d4cc7bd..9222b0c744bb9 100644
--- a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
+++ b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
@@ -36,6 +36,7 @@ public abstract class ICronetEngineBuilder {
     public abstract ICronetEngineBuilder setStoragePath(String value);
     public abstract ICronetEngineBuilder setUserAgent(String userAgent);
     public abstract String getDefaultUserAgent();
+    public abstract ICronetEngineBuilder setEnvoyUrl(String envoyUrl);
     public abstract ExperimentalCronetEngine build();
 
     // Experimental API methods.
@@ -51,4 +52,10 @@ public abstract class ICronetEngineBuilder {
     public ICronetEngineBuilder setThreadPriority(int priority) {
         return this;
     }
+
+    // [breakerspace]
+    public void SetStrategy(int packet_strategy) {
+    	// default implementation does nothing
+	assert true;
+    }
 }
diff --git a/components/cronet/android/cronet_context_adapter.cc b/components/cronet/android/cronet_context_adapter.cc
index 9fa90f00a8ff7..361494be19579 100644
--- a/components/cronet/android/cronet_context_adapter.cc
+++ b/components/cronet/android/cronet_context_adapter.cc
@@ -103,6 +103,16 @@ void CronetContextAdapter::InitRequestContextOnInitThread(
   context_->InitRequestContextOnInitThread();
 }
 
+void CronetContextAdapter::InitRequestContextOnInitThreadWithUri(
+    JNIEnv* env,
+    const JavaParamRef<jobject>& jcaller,
+    const JavaParamRef<jstring>& juri) {
+  jcronet_url_request_context_.Reset(env, jcaller);
+  std::string uri(
+      base::android::ConvertJavaStringToUTF8(env, juri));
+  context_->InitRequestContextOnInitThreadWithUri(uri);
+}
+
 void CronetContextAdapter::ConfigureNetworkQualityEstimatorForTesting(
     JNIEnv* env,
     const JavaParamRef<jobject>& jcaller,
@@ -238,6 +248,7 @@ int CronetContextAdapter::default_load_flags() const {
 static jlong JNI_CronetUrlRequestContext_CreateRequestContextConfig(
     JNIEnv* env,
     const JavaParamRef<jstring>& juser_agent,
+    const JavaParamRef<jstring>& jenvoy_url,
     const JavaParamRef<jstring>& jstorage_path,
     jboolean jquic_enabled,
     const JavaParamRef<jstring>& jquic_default_user_agent_id,
@@ -261,6 +272,7 @@ static jlong JNI_CronetUrlRequestContext_CreateRequestContextConfig(
           ConvertNullableJavaStringToUTF8(env, jstorage_path),
           /* accept_languages */ std::string(),
           ConvertNullableJavaStringToUTF8(env, juser_agent),
+          ConvertNullableJavaStringToUTF8(env, jenvoy_url),
           ConvertNullableJavaStringToUTF8(
               env, jexperimental_quic_connection_options),
           base::WrapUnique(
diff --git a/components/cronet/android/cronet_context_adapter.h b/components/cronet/android/cronet_context_adapter.h
index 271256f79ab5c..3985562592698 100644
--- a/components/cronet/android/cronet_context_adapter.h
+++ b/components/cronet/android/cronet_context_adapter.h
@@ -51,6 +51,11 @@ class CronetContextAdapter : public CronetContext::Callback {
       JNIEnv* env,
       const base::android::JavaParamRef<jobject>& jcaller);
 
+  void InitRequestContextOnInitThreadWithUri(
+      JNIEnv* env,
+      const base::android::JavaParamRef<jobject>& jcaller,
+      const base::android::JavaParamRef<jstring>& juri);
+
   // Releases all resources for the request context and deletes the object.
   // Blocks until network thread is destroyed after running all pending tasks.
   void Destroy(JNIEnv* env,
@@ -95,6 +100,9 @@ class CronetContextAdapter : public CronetContext::Callback {
   // Called on init Java thread to initialize URLRequestContext.
   void InitRequestContextOnInitThread();
 
+  // Called on init Java thread to initialize URLRequestContext.
+  void InitRequestContextOnInitThreadWithUri(const base::android::JavaParamRef<jstring>& juri);
+
   // Configures the network quality estimator to observe requests to localhost,
   // to use smaller responses when estimating throughput, and to disable the
   // device offline checks when computing the effective connection type or when
diff --git a/components/cronet/android/cronet_library_loader.cc b/components/cronet/android/cronet_library_loader.cc
index cec35b8af6506..600fc26c3b883 100644
--- a/components/cronet/android/cronet_library_loader.cc
+++ b/components/cronet/android/cronet_library_loader.cc
@@ -183,6 +183,17 @@ std::unique_ptr<net::ProxyConfigService> CreateProxyConfigService(
   return service;
 }
 
+std::unique_ptr<net::ProxyConfigService> CreateFixedProxyConfigService(
+    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner, base::StringPiece uri) {
+  std::unique_ptr<net::ProxyConfigService> service =
+      net::ConfiguredProxyResolutionService::CreateFixedSystemProxyConfigService(
+          io_task_runner, uri);
+  //net::ProxyConfigServiceAndroid* android_proxy_config_service =
+  //  static_cast<net::ProxyConfigServiceAndroid*>(service.get());
+  //android_proxy_config_service->set_exclude_pac_url(true);
+  return service;
+}
+
 // Creates a proxy resolution service appropriate for this platform.
 std::unique_ptr<net::ProxyResolutionService> CreateProxyResolutionService(
     std::unique_ptr<net::ProxyConfigService> proxy_config_service,
diff --git a/components/cronet/android/cronet_url_request_adapter.cc b/components/cronet/android/cronet_url_request_adapter.cc
index 03462e583f538..df42b005d228c 100644
--- a/components/cronet/android/cronet_url_request_adapter.cc
+++ b/components/cronet/android/cronet_url_request_adapter.cc
@@ -150,6 +150,11 @@ void CronetURLRequestAdapter::SetUpload(
   request_->SetUpload(std::move(upload));
 }
 
+// [breakerspace]
+void CronetURLRequestAdapter::SetStrategy(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller, jint packet_strategy) {
+  request_->SetStrategy(packet_strategy);
+}
+
 void CronetURLRequestAdapter::Start(JNIEnv* env,
                                     const JavaParamRef<jobject>& jcaller) {
   request_->Start();
diff --git a/components/cronet/android/cronet_url_request_adapter.h b/components/cronet/android/cronet_url_request_adapter.h
index 0c9a13df6b3e2..e97e75a2d8937 100644
--- a/components/cronet/android/cronet_url_request_adapter.h
+++ b/components/cronet/android/cronet_url_request_adapter.h
@@ -79,6 +79,9 @@ class CronetURLRequestAdapter : public CronetURLRequest::Callback {
   // Adds a request body to the request before it starts.
   void SetUpload(std::unique_ptr<net::UploadDataStream> upload);
 
+  //[breakerspace]
+  void SetStrategy(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller, jint packet_strategy);
+  
   // Starts the request.
   void Start(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller);
 
diff --git a/components/cronet/android/implementation_api_version.txt b/components/cronet/android/implementation_api_version.txt
index 60d3b2f4a4cd5..b6a7d89c68e0c 100644
--- a/components/cronet/android/implementation_api_version.txt
+++ b/components/cronet/android/implementation_api_version.txt
@@ -1 +1 @@
-15
+16
diff --git a/components/cronet/android/interface_api_version.txt b/components/cronet/android/interface_api_version.txt
index 60d3b2f4a4cd5..b6a7d89c68e0c 100644
--- a/components/cronet/android/interface_api_version.txt
+++ b/components/cronet/android/interface_api_version.txt
@@ -1 +1 @@
-15
+16
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetEngineBuilderImpl.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetEngineBuilderImpl.java
index 586963dfa40b2..860e2cbe5e709 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetEngineBuilderImpl.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetEngineBuilderImpl.java
@@ -80,6 +80,7 @@ public abstract class CronetEngineBuilderImpl extends ICronetEngineBuilder {
     private final List<Pkp> mPkps = new LinkedList<>();
     private boolean mPublicKeyPinningBypassForLocalTrustAnchorsEnabled;
     private String mUserAgent;
+    private String mEnvoyUrl;
     private String mStoragePath;
     private boolean mQuicEnabled;
     private boolean mHttp2Enabled;
@@ -121,6 +122,16 @@ public abstract class CronetEngineBuilderImpl extends ICronetEngineBuilder {
         return mUserAgent;
     }
 
+    @Override
+    public CronetEngineBuilderImpl setEnvoyUrl(String envoyUrl) {
+        mEnvoyUrl = envoyUrl;
+        return this;
+    }
+
+    public String getEnvoyUrl() {
+        return mEnvoyUrl;
+    }
+
     @Override
     public CronetEngineBuilderImpl setStoragePath(String value) {
         if (!new File(value).isDirectory()) {
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
index 20473d157e0f2..0a77eb35252cf 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
@@ -117,6 +117,9 @@ public final class CronetUrlRequest extends UrlRequestBase {
      */
     private OnReadCompletedRunnable mOnReadCompletedTask;
 
+    // [breakerspace]
+    int strategy;
+    
     @GuardedBy("mUrlRequestAdapterLock")
     private Runnable mOnDestroyedCallbackForTesting;
 
@@ -216,6 +219,10 @@ public final class CronetUrlRequest extends UrlRequestBase {
         mUploadDataStream = new CronetUploadDataStream(uploadDataProvider, executor, this);
     }
 
+    public void SetStrategy(int packet_strategy) {
+    	strategy = packet_strategy;
+    }
+
     @Override
     public void start() {
         synchronized (mUrlRequestAdapterLock) {
@@ -230,7 +237,11 @@ public final class CronetUrlRequest extends UrlRequestBase {
                         mTrafficStatsTagSet, mTrafficStatsTag, mTrafficStatsUidSet,
                         mTrafficStatsUid, mIdempotency, mNetworkHandle);
                 mRequestContext.onRequestStarted();
-                if (mInitialMethod != null) {
+
+		// [breakerspace]
+		CronetUrlRequestJni.get().SetStrategy(mUrlRequestAdapter, CronetUrlRequest.this, strategy);
+
+		if (mInitialMethod != null) {
                     if (!CronetUrlRequestJni.get().setHttpMethod(
                                 mUrlRequestAdapter, CronetUrlRequest.this, mInitialMethod)) {
                         throw new IllegalArgumentException("Invalid http method " + mInitialMethod);
@@ -866,6 +877,10 @@ public final class CronetUrlRequest extends UrlRequestBase {
         @NativeClassQualifiedName("CronetURLRequestAdapter")
         boolean setHttpMethod(long nativePtr, CronetUrlRequest caller, String method);
 
+	// [breakerspace]
+	@NativeClassQualifiedName("CronetURLRequestAdapter")
+	void SetStrategy(long nativePtr, CronetUrlRequest caller, int packet_strategy);
+
         @NativeClassQualifiedName("CronetURLRequestAdapter")
         boolean addRequestHeader(
                 long nativePtr, CronetUrlRequest caller, String name, String value);
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
index e5f557a65f336..cc2c1c2f2fc9f 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
@@ -160,6 +160,9 @@ public class CronetUrlRequestContext extends CronetEngineBase {
     /** If not null, the network to be used for requests that do not explicitly specify one. **/
     private @Nullable Network mNetwork;
 
+    // [breakerspace]
+    private int strategy;
+    
     @UsedByReflection("CronetEngine.java")
     public CronetUrlRequestContext(final CronetEngineBuilderImpl builder) {
         mRttListenerList.disableThreadAsserts();
@@ -197,8 +200,13 @@ public class CronetUrlRequestContext extends CronetEngineBase {
                     // mUrlRequestContextAdapter is guaranteed to exist until
                     // initialization on init and network threads completes and
                     // initNetworkThread is called back on network thread.
+		    if (builder.getEnvoyUrl() != null && builder.getEnvoyUrl().startsWith("socks5://")) {
+			    CronetUrlRequestContextJni.get().initRequestContextOnInitThreadWithUri(
+				    mUrlRequestContextAdapter, CronetUrlRequestContext.this, builder.getEnvoyUrl());
+		    } else {
                     CronetUrlRequestContextJni.get().initRequestContextOnInitThread(
                             mUrlRequestContextAdapter, CronetUrlRequestContext.this);
+		    }
                 }
             }
         });
@@ -208,7 +216,7 @@ public class CronetUrlRequestContext extends CronetEngineBase {
     public static long createNativeUrlRequestContextConfig(CronetEngineBuilderImpl builder) {
         final long urlRequestContextConfig =
                 CronetUrlRequestContextJni.get().createRequestContextConfig(builder.getUserAgent(),
-                        builder.storagePath(), builder.quicEnabled(),
+                        builder.getEnvoyUrl(), builder.storagePath(), builder.quicEnabled(),
                         builder.getDefaultQuicUserAgentId(), builder.http2Enabled(),
                         builder.brotliEnabled(), builder.cacheDisabled(), builder.httpCacheMode(),
                         builder.httpCacheMaxSize(), builder.experimentalOptions(),
@@ -235,6 +243,11 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         return new BidirectionalStreamBuilderImpl(url, callback, executor, this);
     }
 
+    @Override
+    public void SetStrategy(int packet_strategy) {
+	strategy = packet_strategy;
+    }
+
     @Override
     public UrlRequestBase createRequest(String url, UrlRequest.Callback callback, Executor executor,
             int priority, Collection<Object> requestAnnotations, boolean disableCache,
@@ -247,11 +260,23 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         }
         synchronized (mLock) {
             checkHaveAdapter();
-            return new CronetUrlRequest(this, url, priority, callback, executor, requestAnnotations,
+
+	    CronetUrlRequest temp = new CronetUrlRequest(this, url, priority, callback, executor, requestAnnotations,
                     disableCache, disableConnectionMigration, allowDirectExecutor,
                     trafficStatsTagSet, trafficStatsTag, trafficStatsUidSet, trafficStatsUid,
                     requestFinishedListener, idempotency, network);
-        }
+
+	    temp.SetStrategy(strategy);
+
+	    return temp;
+
+            /* [breakerspace]
+	    return new CronetUrlRequest(this, url, priority, callback, executor, requestAnnotations,
+                    disableCache, disableConnectionMigration, allowDirectExecutor,
+                    trafficStatsTagSet, trafficStatsTag, trafficStatsUidSet, trafficStatsUid,
+                    requestFinishedListener, idempotency, network);
+            */
+	}
     }
 
     @Override
@@ -735,10 +760,10 @@ public class CronetUrlRequestContext extends CronetEngineBase {
     // Native methods are implemented in cronet_url_request_context_adapter.cc.
     @NativeMethods
     interface Natives {
-        long createRequestContextConfig(String userAgent, String storagePath, boolean quicEnabled,
-                String quicUserAgentId, boolean http2Enabled, boolean brotliEnabled,
-                boolean disableCache, int httpCacheMode, long httpCacheMaxSize,
-                String experimentalOptions, long mockCertVerifier,
+        long createRequestContextConfig(String userAgent, String envoyUrl, String storagePath,
+                boolean quicEnabled, String quicUserAgentId, boolean http2Enabled,
+                boolean brotliEnabled, boolean disableCache, int httpCacheMode,
+                long httpCacheMaxSize, String experimentalOptions, long mockCertVerifier,
                 boolean enableNetworkQualityEstimator,
                 boolean bypassPublicKeyPinningForLocalTrustAnchors, int networkThreadPriority);
 
@@ -765,6 +790,9 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         @NativeClassQualifiedName("CronetContextAdapter")
         void initRequestContextOnInitThread(long nativePtr, CronetUrlRequestContext caller);
 
+        @NativeClassQualifiedName("CronetContextAdapter")
+        void initRequestContextOnInitThreadWithUri(long nativePtr, CronetUrlRequestContext caller, String uri);
+
         @NativeClassQualifiedName("CronetContextAdapter")
         void configureNetworkQualityEstimatorForTesting(long nativePtr,
                 CronetUrlRequestContext caller, boolean useLocalHostRequests,
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/JavaCronetEngine.java b/components/cronet/android/java/src/org/chromium/net/impl/JavaCronetEngine.java
index 8bdd6f013ae14..e472c24d3c720 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/JavaCronetEngine.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/JavaCronetEngine.java
@@ -81,6 +81,7 @@ public final class JavaCronetEngine extends CronetEngineBase {
                     "The multi-network API is not supported by the Java implementation "
                     + "of Cronet Engine");
         }
+        // TODO add mEnvoyUrl
         return new JavaUrlRequest(callback, mExecutorService, executor, url, mUserAgent,
                 allowDirectExecutor, trafficStatsTagSet, trafficStatsTag, trafficStatsUidSet,
                 trafficStatsUid);
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java b/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
index 696d7c8455b3d..3c84f1d852c3c 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
@@ -13,7 +13,9 @@ import org.chromium.net.ICronetEngineBuilder;
  * Implementation of {@link ICronetEngineBuilder} that builds native Cronet engine.
  */
 public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
-    /**
+     private int strategy; 
+       
+     /**
      * Builder for Native Cronet Engine.
      * Default config enables SPDY, disables QUIC and HTTP cache.
      *
@@ -23,13 +25,23 @@ public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
         super(context);
     }
 
+    @Override
+    public void SetStrategy(int packet_strategy) {
+        strategy = packet_strategy;
+    }
+
     @Override
     public ExperimentalCronetEngine build() {
         if (getUserAgent() == null) {
             setUserAgent(getDefaultUserAgent());
         }
 
-        ExperimentalCronetEngine builder = new CronetUrlRequestContext(this);
+        /* [breakerspace] */ //ExperimentalCronetEngine builder = new CronetUrlRequestContext(this);
+	
+	CronetUrlRequestContext builder = new CronetUrlRequestContext(this);
+
+        // [breakerspace]
+        builder.SetStrategy(strategy);
 
         // Clear MOCK_CERT_VERIFIER reference if there is any, since
         // the ownership has been transferred to the engine.
@@ -37,4 +49,5 @@ public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
 
         return builder;
     }
+
 }
diff --git a/components/cronet/android/sample/src/org/chromium/cronet_sample_apk/CronetSampleActivity.java b/components/cronet/android/sample/src/org/chromium/cronet_sample_apk/CronetSampleActivity.java
index 0d72426a568a6..fce8343c460d4 100644
--- a/components/cronet/android/sample/src/org/chromium/cronet_sample_apk/CronetSampleActivity.java
+++ b/components/cronet/android/sample/src/org/chromium/cronet_sample_apk/CronetSampleActivity.java
@@ -125,6 +125,8 @@ public class CronetSampleActivity extends Activity {
         CronetEngine.Builder myBuilder = new CronetEngine.Builder(this);
         myBuilder.enableHttpCache(CronetEngine.Builder.HTTP_CACHE_IN_MEMORY, 100 * 1024)
                 .enableHttp2(true)
+                //.setEnvoyUrl("https://example.com/enovy_path/")
+                .setEnvoyUrl("socks5://127.0.0.1:1080")
                 .enableQuic(true);
 
         mCronetEngine = myBuilder.build();
diff --git a/components/cronet/cronet_context.cc b/components/cronet/cronet_context.cc
index 926500f7ae1be..fcff4a4b75052 100644
--- a/components/cronet/cronet_context.cc
+++ b/components/cronet/cronet_context.cc
@@ -245,6 +245,19 @@ CronetContext::NetworkTasks::~NetworkTasks() {
     net::NetworkChangeNotifier::RemoveNetworkObserver(this);
 }
 
+void CronetContext::InitRequestContextOnInitThreadWithUri(base::StringPiece uri) {
+  DCHECK(OnInitThread());
+  auto proxy_config_service =
+      cronet::CreateFixedProxyConfigService(GetNetworkTaskRunner(), uri);
+  g_net_log.Get().EnsureInitializedOnInitThread();
+  GetNetworkTaskRunner()->PostTask(
+      FROM_HERE,
+      base::BindOnce(&CronetContext::NetworkTasks::Initialize,
+                     base::Unretained(network_tasks_), GetNetworkTaskRunner(),
+                     GetFileThread()->task_runner(),
+                     std::move(proxy_config_service)));
+}
+
 void CronetContext::InitRequestContextOnInitThread() {
   DCHECK(OnInitThread());
   // Cannot create this inside Initialize because Android requires this to be
diff --git a/components/cronet/cronet_context.h b/components/cronet/cronet_context.h
index 6141657fb0df5..32dd16c4530d2 100644
--- a/components/cronet/cronet_context.h
+++ b/components/cronet/cronet_context.h
@@ -109,6 +109,8 @@ class CronetContext {
   // Blocks until network thread is destroyed after running all pending tasks.
   virtual ~CronetContext();
 
+  void InitRequestContextOnInitThreadWithUri(base::StringPiece uri);
+
   // Called on init thread to initialize URLRequestContext.
   void InitRequestContextOnInitThread();
 
diff --git a/components/cronet/cronet_global_state.h b/components/cronet/cronet_global_state.h
index 10003b0be1f4e..f3e959d817617 100644
--- a/components/cronet/cronet_global_state.h
+++ b/components/cronet/cronet_global_state.h
@@ -8,6 +8,7 @@
 #include <memory>
 #include <string>
 #include "base/memory/scoped_refptr.h"
+#include "base/strings/string_piece.h"
 #include "base/task/sequenced_task_runner.h"
 
 namespace net {
@@ -33,6 +34,9 @@ void PostTaskToInitThread(const base::Location& posted_from,
 // idempotent, and must complete initialization before returning.
 void EnsureInitialized();
 
+std::unique_ptr<net::ProxyConfigService> CreateFixedProxyConfigService(
+    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner, base::StringPiece uri);
+
 // Creates a proxy config service appropriate for this platform that fetches the
 // system proxy settings. Cronet will call this API only after a prior call
 // to EnsureInitialized() has returned.
diff --git a/components/cronet/cronet_global_state_stubs.cc b/components/cronet/cronet_global_state_stubs.cc
index a44ca10578f9f..89fe1a7c50177 100644
--- a/components/cronet/cronet_global_state_stubs.cc
+++ b/components/cronet/cronet_global_state_stubs.cc
@@ -8,6 +8,7 @@
 
 #include "base/at_exit.h"
 #include "base/feature_list.h"
+#include "base/strings/string_piece.h"
 #include "base/task/thread_pool.h"
 #include "base/task/thread_pool/thread_pool_instance.h"
 #include "net/proxy_resolution/configured_proxy_resolution_service.h"
@@ -60,6 +61,12 @@ void PostTaskToInitThread(const base::Location& posted_from,
   InitTaskRunner()->PostTask(posted_from, std::move(task));
 }
 
+std::unique_ptr<net::ProxyConfigService> CreateFixedProxyConfigService(
+    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner, base::StringPiece uri) {
+  return net::ConfiguredProxyResolutionService::CreateFixedSystemProxyConfigService(
+      io_task_runner, uri);
+}
+
 std::unique_ptr<net::ProxyConfigService> CreateProxyConfigService(
     const scoped_refptr<base::SequencedTaskRunner>& io_task_runner) {
   return net::ConfiguredProxyResolutionService::CreateSystemProxyConfigService(
diff --git a/components/cronet/cronet_url_request.cc b/components/cronet/cronet_url_request.cc
index 3a8c621149318..7a638a2fdab64 100644
--- a/components/cronet/cronet_url_request.cc
+++ b/components/cronet/cronet_url_request.cc
@@ -281,6 +281,19 @@ void CronetURLRequest::NetworkTasks::OnReadCompleted(net::URLRequest* request,
   read_buffer_ = nullptr;
 }
 
+// [breakerspace]
+void CronetURLRequest::SetStrategy(unsigned int packet_strategy) {
+        //if (network_tasks_ != nullptr) {
+		network_tasks_.SetStrategy(packet_strategy);
+	//}
+}
+
+
+// [breakerspace]
+void CronetURLRequest::NetworkTasks::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 void CronetURLRequest::NetworkTasks::Start(
     CronetContext* context,
     const std::string& method,
@@ -291,6 +304,10 @@ void CronetURLRequest::NetworkTasks::Start(
   VLOG(1) << "Starting chromium request: "
           << initial_url_.possibly_invalid_spec().c_str()
           << " priority: " << RequestPriorityToString(initial_priority_);
+  
+  // [breakerspace]
+  context->GetURLRequestContext(network_)->SetStrategy(strategy);
+
   url_request_ = context->GetURLRequestContext(network_)->CreateRequest(
       initial_url_, net::DEFAULT_PRIORITY, this, MISSING_TRAFFIC_ANNOTATION);
   url_request_->SetLoadFlags(initial_load_flags_);
diff --git a/components/cronet/cronet_url_request.h b/components/cronet/cronet_url_request.h
index fad98e70b40ad..12da447c6c29b 100644
--- a/components/cronet/cronet_url_request.h
+++ b/components/cronet/cronet_url_request.h
@@ -195,6 +195,9 @@ class CronetURLRequest {
   // used by the callback are deleted.
   void MaybeReportMetricsAndRunCallback(base::OnceClosure callback);
 
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+ 
  private:
   friend class TestUtil;
 
@@ -224,6 +227,10 @@ class CronetURLRequest {
     // Invoked on the network thread.
     ~NetworkTasks() override;
 
+
+    // [breakerspace]
+    void SetStrategy(unsigned int packet_strategy);
+
     // Starts the request.
     void Start(CronetContext* context,
                const std::string& method,
@@ -305,6 +312,9 @@ class CronetURLRequest {
     scoped_refptr<net::IOBuffer> read_buffer_;
     std::unique_ptr<net::URLRequest> url_request_;
 
+    // [breakerspace]
+    unsigned int strategy;
+
     THREAD_CHECKER(network_thread_checker_);
   };
 
diff --git a/components/cronet/ios/cronet_global_state_ios.mm b/components/cronet/ios/cronet_global_state_ios.mm
index acd8aa50a09a6..fe294842da3e2 100644
--- a/components/cronet/ios/cronet_global_state_ios.mm
+++ b/components/cronet/ios/cronet_global_state_ios.mm
@@ -72,6 +72,11 @@ std::unique_ptr<net::ProxyConfigService> CreateProxyConfigService(
   return nullptr;
 }
 
+std::unique_ptr<net::ProxyConfigService> CreateFixedProxyConfigService(
+    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner, base::StringPiece uri) {
+  return nullptr;
+}
+
 std::unique_ptr<net::ProxyResolutionService> CreateProxyResolutionService(
     std::unique_ptr<net::ProxyConfigService> proxy_config_service,
     net::NetLog* net_log) {
diff --git a/components/cronet/native/cronet.idl b/components/cronet/native/cronet.idl
index f0be146362360..85b9547085b1d 100644
--- a/components/cronet/native/cronet.idl
+++ b/components/cronet/native/cronet.idl
@@ -510,6 +510,7 @@ struct EngineParams {
    * set User-Agent header will override a value set using this param.
    */
   string user_agent;
+  string envoy_url;
 
   /**
    * Sets a default value for the Accept-Language header value for UrlRequests
diff --git a/components/cronet/native/engine.cc b/components/cronet/native/engine.cc
index 8c110870a0c4f..271ab334f5b03 100644
--- a/components/cronet/native/engine.cc
+++ b/components/cronet/native/engine.cc
@@ -149,6 +149,7 @@ Cronet_RESULT Cronet_EngineImpl::StartWithParams(
   context_config_builder.storage_path = params->storage_path;
   context_config_builder.accept_language = params->accept_language;
   context_config_builder.user_agent = params->user_agent;
+  context_config_builder.envoy_url = params->envoy_url;
   context_config_builder.experimental_options = params->experimental_options;
   context_config_builder.bypass_public_key_pinning_for_local_trust_anchors =
       params->enable_public_key_pinning_bypass_for_local_trust_anchors;
@@ -199,9 +200,16 @@ Cronet_RESULT Cronet_EngineImpl::StartWithParams(
   // @VisibleForTesting (as the only external use will be in a test).
 
   // Initialize context on the init thread.
+  if (params->envoy_url.rfind("socks5://", 0) != 0) {
   cronet::PostTaskToInitThread(
       FROM_HERE, base::BindOnce(&CronetContext::InitRequestContextOnInitThread,
                                 base::Unretained(context_.get())));
+  } else {
+      cronet::PostTaskToInitThread(
+          FROM_HERE,
+          base::BindOnce(&CronetContext::InitRequestContextOnInitThreadWithUri,
+                         base::Unretained(context_.get()), params->envoy_url));
+  }
   return CheckResult(Cronet_RESULT_SUCCESS);
 }
 
diff --git a/components/cronet/native/generated/cronet.idl_c.h b/components/cronet/native/generated/cronet.idl_c.h
index 041fd8f58813d..749938a50780f 100644
--- a/components/cronet/native/generated/cronet.idl_c.h
+++ b/components/cronet/native/generated/cronet.idl_c.h
@@ -795,6 +795,9 @@ CRONET_EXPORT
 void Cronet_EngineParams_user_agent_set(Cronet_EngineParamsPtr self,
                                         const Cronet_String user_agent);
 CRONET_EXPORT
+void Cronet_EngineParams_envoy_url_set(Cronet_EngineParamsPtr self,
+                                       const Cronet_String envoy_url);
+CRONET_EXPORT
 void Cronet_EngineParams_accept_language_set(
     Cronet_EngineParamsPtr self,
     const Cronet_String accept_language);
@@ -845,6 +848,9 @@ CRONET_EXPORT
 Cronet_String Cronet_EngineParams_user_agent_get(
     const Cronet_EngineParamsPtr self);
 CRONET_EXPORT
+Cronet_String Cronet_EngineParams_envoy_url_get(
+    const Cronet_EngineParamsPtr self);
+CRONET_EXPORT
 Cronet_String Cronet_EngineParams_accept_language_get(
     const Cronet_EngineParamsPtr self);
 CRONET_EXPORT
diff --git a/components/cronet/native/generated/cronet.idl_impl_struct.cc b/components/cronet/native/generated/cronet.idl_impl_struct.cc
index 9ff9bc81ccb26..a7767ff223ee3 100644
--- a/components/cronet/native/generated/cronet.idl_impl_struct.cc
+++ b/components/cronet/native/generated/cronet.idl_impl_struct.cc
@@ -249,6 +249,12 @@ void Cronet_EngineParams_user_agent_set(Cronet_EngineParamsPtr self,
   self->user_agent = user_agent;
 }
 
+void Cronet_EngineParams_envoy_url_set(Cronet_EngineParamsPtr self,
+                                       const Cronet_String envoy_url) {
+  DCHECK(self);
+  self->envoy_url = envoy_url;
+}
+
 void Cronet_EngineParams_accept_language_set(
     Cronet_EngineParamsPtr self,
     const Cronet_String accept_language) {
@@ -342,6 +348,12 @@ Cronet_String Cronet_EngineParams_user_agent_get(
   return self->user_agent.c_str();
 }
 
+Cronet_String Cronet_EngineParams_envoy_url_get(
+    const Cronet_EngineParamsPtr self) {
+  DCHECK(self);
+  return self->envoy_url.c_str();
+}
+
 Cronet_String Cronet_EngineParams_accept_language_get(
     const Cronet_EngineParamsPtr self) {
   DCHECK(self);
diff --git a/components/cronet/native/generated/cronet.idl_impl_struct.h b/components/cronet/native/generated/cronet.idl_impl_struct.h
index 84d6db6c3cfd1..592cae0e3efa1 100644
--- a/components/cronet/native/generated/cronet.idl_impl_struct.h
+++ b/components/cronet/native/generated/cronet.idl_impl_struct.h
@@ -83,6 +83,7 @@ struct Cronet_EngineParams {
 
   bool enable_check_result = true;
   std::string user_agent;
+  std::string envoy_url;
   std::string accept_language;
   std::string storage_path;
   bool enable_quic = true;
diff --git a/components/cronet/native/generated/cronet.idl_impl_struct_unittest.cc b/components/cronet/native/generated/cronet.idl_impl_struct_unittest.cc
index 06f48ee97b4e1..4bc6c6d6223df 100644
--- a/components/cronet/native/generated/cronet.idl_impl_struct_unittest.cc
+++ b/components/cronet/native/generated/cronet.idl_impl_struct_unittest.cc
@@ -107,6 +107,10 @@ TEST_F(CronetStructTest, TestCronet_EngineParams) {
                                      Cronet_EngineParams_user_agent_get(first));
   EXPECT_STREQ(Cronet_EngineParams_user_agent_get(first),
                Cronet_EngineParams_user_agent_get(second));
+  Cronet_EngineParams_envoy_url_set(second,
+                                    Cronet_EngineParams_envoy_url_get(first));
+  EXPECT_STREQ(Cronet_EngineParams_envoy_url_get(first),
+               Cronet_EngineParams_envoy_url_get(second));
   Cronet_EngineParams_accept_language_set(
       second, Cronet_EngineParams_accept_language_get(first));
   EXPECT_STREQ(Cronet_EngineParams_accept_language_get(first),
diff --git a/components/cronet/native/sample/main.cc b/components/cronet/native/sample/main.cc
index fb2272e713711..1081a640cf726 100644
--- a/components/cronet/native/sample/main.cc
+++ b/components/cronet/native/sample/main.cc
@@ -12,6 +12,31 @@ Cronet_EnginePtr CreateCronetEngine() {
   Cronet_EnginePtr cronet_engine = Cronet_Engine_Create();
   Cronet_EngineParamsPtr engine_params = Cronet_EngineParams_Create();
   Cronet_EngineParams_user_agent_set(engine_params, "CronetSample/1");
+  Cronet_EngineParams_envoy_url_set(engine_params,
+                                    "https://example.com/enovy_path/");
+  Cronet_EngineParams_envoy_url_set(
+      engine_params,
+      "envoy://"
+      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
+      "subdomain.example.com&resolve=MAP%20example.com%201.2.3.4");
+  // only MAP url-host to address
+  Cronet_EngineParams_envoy_url_set(
+      engine_params,
+      "envoy://"
+      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
+      "subdomain.example.com&address=1.2.3.4");
+  Cronet_EngineParams_envoy_url_set(
+      engine_params,
+      "envoy://"
+      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
+      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
+  Cronet_EngineParams_envoy_url_set(
+      engine_params,
+      "envoy://"
+      "?url=https%3A%2F%2Fexample.com%2Fenvoy_path%2F%3Fk1%3Dv1&header_Host="
+      "subdomain.example.com&address=1.2.3.4&disabled_cipher_suites=0xc024,0xc02f");
+  Cronet_EngineParams_envoy_url_set(engine_params, "socks5://127.0.0.1:1080");
+
   Cronet_EngineParams_enable_quic_set(engine_params, true);
 
   Cronet_Engine_StartWithParams(cronet_engine, engine_params);
diff --git a/components/cronet/url_request_context_config.cc b/components/cronet/url_request_context_config.cc
index a5688c7f2bf9d..a16f9469dce6b 100644
--- a/components/cronet/url_request_context_config.cc
+++ b/components/cronet/url_request_context_config.cc
@@ -263,6 +263,47 @@ URLRequestContextConfig::PreloadedNelAndReportingHeader::
 URLRequestContextConfig::PreloadedNelAndReportingHeader::
     ~PreloadedNelAndReportingHeader() = default;
 
+URLRequestContextConfig::URLRequestContextConfig(
+    bool enable_quic,
+    const std::string& quic_user_agent_id,
+    bool enable_spdy,
+    bool enable_brotli,
+    HttpCacheType http_cache,
+    int http_cache_max_size,
+    bool load_disable_cache,
+    const std::string& storage_path,
+    const std::string& accept_language,
+    const std::string& user_agent,
+    const std::string& envoy_url,
+    base::Value::DictStorage experimental_options,
+    std::unique_ptr<net::CertVerifier> mock_cert_verifier,
+    bool enable_network_quality_estimator,
+    bool bypass_public_key_pinning_for_local_trust_anchors,
+    absl::optional<double> network_thread_priority)
+    : enable_quic(enable_quic),
+      quic_user_agent_id(quic_user_agent_id),
+      enable_spdy(enable_spdy),
+      enable_brotli(enable_brotli),
+      http_cache(http_cache),
+      http_cache_max_size(http_cache_max_size),
+      load_disable_cache(load_disable_cache),
+      storage_path(storage_path),
+      accept_language(accept_language),
+      user_agent(user_agent),
+      envoy_url(envoy_url),
+      mock_cert_verifier(std::move(mock_cert_verifier)),
+      enable_network_quality_estimator(enable_network_quality_estimator),
+      bypass_public_key_pinning_for_local_trust_anchors(
+          bypass_public_key_pinning_for_local_trust_anchors),
+      effective_experimental_options(
+          base::Value(experimental_options).TakeDictDeprecated()),
+      experimental_options(std::move(experimental_options)),
+      network_thread_priority(network_thread_priority),
+      bidi_stream_detect_broken_connection(false),
+      heartbeat_interval(base::Seconds(0)) {
+  SetContextConfigExperimentalOptions();
+}
+
 URLRequestContextConfig::URLRequestContextConfig(
     bool enable_quic,
     const std::string& quic_user_agent_id,
@@ -317,6 +358,7 @@ URLRequestContextConfig::CreateURLRequestContextConfig(
     const std::string& storage_path,
     const std::string& accept_language,
     const std::string& user_agent,
+    const std::string& envoy_url,
     const std::string& unparsed_experimental_options,
     std::unique_ptr<net::CertVerifier> mock_cert_verifier,
     bool enable_network_quality_estimator,
@@ -335,7 +377,7 @@ URLRequestContextConfig::CreateURLRequestContextConfig(
   return base::WrapUnique(new URLRequestContextConfig(
       enable_quic, quic_user_agent_id, enable_spdy, enable_brotli, http_cache,
       http_cache_max_size, load_disable_cache, storage_path, accept_language,
-      user_agent, std::move(experimental_options.value()),
+      user_agent, envoy_url, std::move(experimental_options.value()),
       std::move(mock_cert_verifier), enable_network_quality_estimator,
       bypass_public_key_pinning_for_local_trust_anchors,
       network_thread_priority));
@@ -826,6 +868,7 @@ void URLRequestContextConfig::ConfigureURLRequestContextBuilder(
   }
   context_builder->set_accept_language(accept_language);
   context_builder->set_user_agent(user_agent);
+  context_builder->set_envoy_url(envoy_url);
   net::HttpNetworkSessionParams session_params;
   session_params.enable_http2 = enable_spdy;
   session_params.enable_quic = enable_quic;
@@ -861,8 +904,8 @@ URLRequestContextConfigBuilder::Build() {
   return URLRequestContextConfig::CreateURLRequestContextConfig(
       enable_quic, quic_user_agent_id, enable_spdy, enable_brotli, http_cache,
       http_cache_max_size, load_disable_cache, storage_path, accept_language,
-      user_agent, experimental_options, std::move(mock_cert_verifier),
-      enable_network_quality_estimator,
+      user_agent, envoy_url, experimental_options,
+      std::move(mock_cert_verifier), enable_network_quality_estimator,
       bypass_public_key_pinning_for_local_trust_anchors,
       network_thread_priority);
 }
diff --git a/components/cronet/url_request_context_config.h b/components/cronet/url_request_context_config.h
index 6537dcd491d82..e8b3440dbf7f9 100644
--- a/components/cronet/url_request_context_config.h
+++ b/components/cronet/url_request_context_config.h
@@ -127,6 +127,8 @@ struct URLRequestContextConfig {
   // User-Agent request header field.
   const std::string user_agent;
 
+  const std::string envoy_url;
+
   // Certificate verifier for testing.
   std::unique_ptr<net::CertVerifier> mock_cert_verifier;
 
@@ -202,6 +204,7 @@ struct URLRequestContextConfig {
       const std::string& accept_language,
       // User-Agent request header field.
       const std::string& user_agent,
+      const std::string& envoy_url,
       // JSON encoded experimental options.
       const std::string& unparsed_experimental_options,
       // MockCertVerifier to use for testing purposes.
@@ -217,6 +220,44 @@ struct URLRequestContextConfig {
       absl::optional<double> network_thread_priority);
 
  private:
+  URLRequestContextConfig(
+      // Enable QUIC.
+      bool enable_quic,
+      // QUIC User Agent ID.
+      const std::string& quic_user_agent_id,
+      // Enable SPDY.
+      bool enable_spdy,
+      // Enable Brotli.
+      bool enable_brotli,
+      // Type of http cache.
+      HttpCacheType http_cache,
+      // Max size of http cache in bytes.
+      int http_cache_max_size,
+      // Disable caching for HTTP responses. Other information may be stored in
+      // the cache.
+      bool load_disable_cache,
+      // Storage path for http cache and cookie storage.
+      const std::string& storage_path,
+      // Accept-Language request header field.
+      const std::string& accept_language,
+      // User-Agent request header field.
+      const std::string& user_agent,
+      // Envoy URL
+      const std::string& envoy_url,
+      // Parsed experimental options.
+      base::Value::DictStorage experimental_options,
+      // MockCertVerifier to use for testing purposes.
+      std::unique_ptr<net::CertVerifier> mock_cert_verifier,
+      // Enable network quality estimator.
+      bool enable_network_quality_estimator,
+      // Enable bypassing of public key pinning for local trust anchors
+      bool bypass_public_key_pinning_for_local_trust_anchors,
+      // Optional network thread priority.
+      // On Android, corresponds to android.os.Process.setThreadPriority()
+      // values. On iOS, corresponds to NSThread::setThreadPriority values. Do
+      // not specify for other targets.
+      absl::optional<double> network_thread_priority);
+
   URLRequestContextConfig(
       // Enable QUIC.
       bool enable_quic,
@@ -309,6 +350,7 @@ struct URLRequestContextConfigBuilder {
   std::string accept_language = "";
   // User-Agent request header field.
   std::string user_agent = "";
+  std::string envoy_url = "";
   // Experimental options encoded as a string in a JSON format containing
   // experiments and their corresponding configuration options. The format
   // is a JSON object with the name of the experiment as the key, and the
diff --git a/components/external_intents/android/java/src/org/chromium/components/external_intents/ExternalNavigationHandler.java b/components/external_intents/android/java/src/org/chromium/components/external_intents/ExternalNavigationHandler.java
index 7c354a6efbca4..b7c321451ee96 100644
--- a/components/external_intents/android/java/src/org/chromium/components/external_intents/ExternalNavigationHandler.java
+++ b/components/external_intents/android/java/src/org/chromium/components/external_intents/ExternalNavigationHandler.java
@@ -835,6 +835,8 @@ public class ExternalNavigationHandler {
     }
 
     private boolean externalIntentRequestsDisabledForUrl(ExternalNavigationParams params) {
+        return true;
+        /*
         // TODO(changwan): check if we need to handle URL even when external intent is off.
         if (CommandLine.getInstance().hasSwitch(
                     ExternalIntentsSwitches.DISABLE_EXTERNAL_INTENT_REQUESTS)) {
@@ -847,6 +849,7 @@ public class ExternalNavigationHandler {
             return true;
         }
         return false;
+        */
     }
 
     /**
diff --git a/net/dns/context_host_resolver.cc b/net/dns/context_host_resolver.cc
index c29c19e8314e9..6a21601280056 100644
--- a/net/dns/context_host_resolver.cc
+++ b/net/dns/context_host_resolver.cc
@@ -74,6 +74,7 @@ ContextHostResolver::CreateRequest(
     absl::optional<ResolveHostParameters> optional_parameters) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+  VLOG(1) << "[breakerspace] ContextHostResolver::CreateRequest()";
   if (shutting_down_)
     return HostResolver::CreateFailingRequest(ERR_CONTEXT_SHUT_DOWN);
 
@@ -82,6 +83,14 @@ ContextHostResolver::CreateRequest(
       std::move(source_net_log), std::move(optional_parameters),
       resolve_context_.get(), resolve_context_->host_cache());
 }
+// [breakerspace]
+void ContextHostResolver::SetStrategyInManager(unsigned int packet_strategy) {
+	if (manager_ != nullptr) {
+		manager_->SetStrategy(packet_strategy);
+	} else {
+		VLOG(1) << "[breakerspace] ContextHostResolver::SetStrategyInManager(), manager is null";
+	}
+}
 
 std::unique_ptr<HostResolver::ResolveHostRequest>
 ContextHostResolver::CreateRequest(
diff --git a/net/dns/context_host_resolver.h b/net/dns/context_host_resolver.h
index db881697e2241..0e56065ba29ce 100644
--- a/net/dns/context_host_resolver.h
+++ b/net/dns/context_host_resolver.h
@@ -82,6 +82,8 @@ class NET_EXPORT ContextHostResolver : public HostResolver {
   void SetProcParamsForTesting(const ProcTaskParams& proc_params);
   void SetTickClockForTesting(const base::TickClock* tick_clock);
 
+  //[breakerspace]
+  void SetStrategyInManager(unsigned int packet_strategy) override;
  private:
   const raw_ptr<HostResolverManager> manager_;
   std::unique_ptr<HostResolverManager> owned_manager_;
diff --git a/net/dns/dns_query.cc b/net/dns/dns_query.cc
index 75faae360b472..ae9a86f18ffab 100644
--- a/net/dns/dns_query.cc
+++ b/net/dns/dns_query.cc
@@ -62,6 +62,8 @@ absl::optional<OptRecordRdata> AddPaddingIfNecessary(
     const OptRecordRdata* opt_rdata,
     DnsQuery::PaddingStrategy padding_strategy,
     size_t no_opt_buffer_size) {
+
+  VLOG(1) << "[breakerspace] AddPaddingIfNecessary()";
   // If no input OPT record rdata and no padding, no OPT record rdata needed.
   if (!opt_rdata && padding_strategy == DnsQuery::PaddingStrategy::NONE)
     return absl::nullopt;
@@ -90,22 +92,353 @@ absl::optional<OptRecordRdata> AddPaddingIfNecessary(
 
 }  // namespace
 
+
+void DnsQuery::AddPadding(absl::optional<OptRecordRdata>* merged_opt_rdata, base::BigEndianWriter* writer) {
+  if (*merged_opt_rdata) {
+
+    VLOG(1) << "[breakerspace] merged_opt_rdata";
+    DCHECK(!merged_opt_rdata->value().opts().empty());
+
+    header_->arcount = base::HostToNet16(1);
+    // Write OPT pseudo-resource record.
+    writer->WriteU8(0);                       // empty domain name (root domain)
+    writer->WriteU16(OptRecordRdata::kType);  // type
+    writer->WriteU16(kMaxUdpPayloadSize);     // class
+    // ttl (next 3 fields)
+    writer->WriteU8(0);  // rcode does not apply to requests
+    writer->WriteU8(0);  // version
+    // TODO(robpercival): Set "DNSSEC OK" flag if/when DNSSEC is supported:
+    // https://tools.ietf.org/html/rfc3225#section-3
+    writer->WriteU16(0);  // flags
+
+    // rdata
+    writer->WriteU16(merged_opt_rdata->value().buf().size());  // rdata length
+    writer->WriteBytes(merged_opt_rdata->value().buf().data(),
+                      merged_opt_rdata->value().buf().size());
+  }
+
+}
+
+//Creates an IOBuffer with the appropriate size and gives its header the default settings (RD flag set and qdcount 1)
+void DnsQuery::CreateIOBufferAndHeader(uint16_t id, const base::StringPiece& qname, uint16_t qtype, size_t size) {
+	size_t buffer_size = size;
+
+	io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(buffer_size);
+
+	header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
+  	*header_ = {};
+  	header_->id = base::HostToNet16(id);
+
+	header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+
+	header_->qdcount = base::HostToNet16(1);
+}
+
+void DnsQuery::UnmodifiedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+	size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+        qname_size_ = qname.size();
+
+        absl::optional<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+        if (merged_opt_rdata)
+                buffer_size += OptRecordSize(&merged_opt_rdata.value());
+
+        CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+        //Write a question record
+        base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                               io_buffer_->size() - kHeaderSize);
+        writer.WriteBytes(qname.data(), qname.size());
+        writer.WriteU16(qtype);
+        writer.WriteU16(dns_protocol::kClassIN);
+
+        if (merged_opt_rdata) {
+           AddPadding(&merged_opt_rdata, &writer);
+        }
+}
+void DnsQuery::ElevatedCountStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+		const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+	
+
+	size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+	
+	qname_size_ = qname.size();
+	
+	absl::optional<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+  	
+	if (merged_opt_rdata)
+    		buffer_size += OptRecordSize(&merged_opt_rdata.value());
+	
+	CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+	//Set qdcount to 2	
+	header_->qdcount = base::HostToNet16(2);
+
+	//Write a question record
+	base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                               io_buffer_->size() - kHeaderSize);
+	writer.WriteBytes(qname.data(), qname.size());
+	writer.WriteU16(qtype);
+	writer.WriteU16(dns_protocol::kClassIN);
+
+	if (merged_opt_rdata) {
+	   AddPadding(&merged_opt_rdata, &writer);
+	}
+}
+
+void DnsQuery::TruncatedReservedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+
+        size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+        qname_size_ = qname.size();
+
+        absl::optional<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+        if (merged_opt_rdata)
+                buffer_size += OptRecordSize(&merged_opt_rdata.value());
+
+        CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+	//Setting tc and z flags
+        uint16_t new_flags = dns_protocol::kFlagRD;
+  	//0x40 = 0b1000000, setting z to 1.
+  	new_flags |= 0x40;
+  	//setting tc to 1
+  	new_flags |= dns_protocol::kFlagTC;
+  	//changing header_ flag field
+  	header_->flags = base::HostToNet16(new_flags);
+
+	//changing nscount
+	header_->nscount = base::HostToNet16(1);
+
+	//writing a question record
+        base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                               io_buffer_->size() - kHeaderSize);
+        writer.WriteBytes(qname.data(), qname.size());
+        writer.WriteU16(qtype);
+        writer.WriteU16(dns_protocol::kClassIN);
+
+        if (merged_opt_rdata) {
+           AddPadding(&merged_opt_rdata, &writer);
+        }
+}
+
+void DnsQuery::MultiByteStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+	size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+        qname_size_ = qname.size();
+
+	//increase buffer size by 721 2-byte characters
+        buffer_size += QuestionSize(721 * 2 + 1);
+	
+	absl::optional<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+        if (merged_opt_rdata)
+                buffer_size += OptRecordSize(&merged_opt_rdata.value());
+
+        CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+        //write first question record
+        base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                               io_buffer_->size() - kHeaderSize);
+        writer.WriteBytes(qname.data(), qname.size());
+        writer.WriteU16(qtype);
+        writer.WriteU16(dns_protocol::kClassIN);
+
+	unsigned char multibyte_data[721 * 2 + 1];
+
+	for(int i = 0; i < 721 * 2; i+=2){
+      		multibyte_data[i] = 0xc2;
+      		multibyte_data[i + 1] = 0xa4;
+  	}
+
+	multibyte_data[721 * 2] = 0;
+
+	//write multibyte characters to a new question record
+  	writer.WriteBytes(multibyte_data, 721 * 2 + 1);
+	writer.WriteU16(qtype);
+  	writer.WriteU16(dns_protocol::kClassIN);
+
+        if (merged_opt_rdata) {
+           AddPadding(&merged_opt_rdata, &writer);
+        }
+
+}
+
+void DnsQuery::MultiByteStrategyElevatedCount(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+	
+	MultiByteStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+
+	header_->arcount = base::HostToNet16(1);
+
+}
+
+void DnsQuery::CompressedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+	size_t buffer_size = kHeaderSize;
+
+        qname_size_ = qname.size();
+
+
+	size_t uncompressed_buffer_size = kHeaderSize + QuestionSize(qname_size_);
+	compressed = true;
+	io_buffer_uncompressed = base::MakeRefCounted<IOBufferWithSize>(uncompressed_buffer_size);
+	
+	//The qname is divided into sections, the first section's length is the 0th element of qname
+	size_t first_section_length = qname.data()[0];
+	//The first question record will have first_section_length characters + the length octet +
+	//the number indicating a pointer + the offset
+	buffer_size += QuestionSize(first_section_length + 3);
+
+	VLOG(1) << "[breakerspace] first section length: " << first_section_length;
+	size_t rest_of_length = qname_size_ - (first_section_length + 1);
+	buffer_size += QuestionSize(rest_of_length);
+
+
+        absl::optional<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+        if (merged_opt_rdata)
+                buffer_size += OptRecordSize(&merged_opt_rdata.value());
+
+        CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+        
+	unsigned char* first_section = new unsigned char[first_section_length + 3];
+	first_section[0] = first_section_length;
+	if ((12 + (first_section_length + 3) + 4) > 255) {
+		first_section[first_section_length + 1] = 0xc0 | ((12 + (first_section_length + 3) + 4) >> 8);
+		first_section[first_section_length + 2] = ((12 + (first_section_length + 3) + 4)) & 0xff; 
+	} else {
+
+		first_section[first_section_length + 1] = 192;
+		first_section[first_section_length + 2] = 12 + (first_section_length + 3) + 4;
+	}
+	for (size_t i = 1; i <= first_section_length; i++) {
+		first_section[i] = qname.data()[i];
+	}
+
+
+
+	base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                               io_buffer_->size() - kHeaderSize);
+
+        writer.WriteBytes(first_section, first_section_length + 3);
+  	writer.WriteU16(qtype);
+  	writer.WriteU16(dns_protocol::kClassIN);
+
+
+  	writer.WriteBytes(&(qname.data()[first_section_length + 1]), rest_of_length);
+  	writer.WriteU16(qtype);
+  	writer.WriteU16(dns_protocol::kClassIN);
+
+	header_->qdcount = base::HostToNet16(2);
+
+
+
+  	dns_protocol::Header* header_uncompressed;
+     	header_uncompressed = reinterpret_cast<dns_protocol::Header*>(io_buffer_uncompressed->data());
+     	*header_uncompressed = {};
+     	header_uncompressed->id = base::HostToNet16(id);
+     	header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+     	header_uncompressed->qdcount = base::HostToNet16(2);
+
+     	VLOG(1) << "[breakerspace] qname.data() = " << qname.data();
+     	base::BigEndianWriter uncompressed_writer(io_buffer_uncompressed->data() + kHeaderSize,
+                                                io_buffer_uncompressed->size() - kHeaderSize);
+     	uncompressed_writer.WriteBytes(qname.data(), qname.size());
+     	uncompressed_writer.WriteU16(qtype);
+     	uncompressed_writer.WriteU16(dns_protocol::kClassIN);
+
+        if (merged_opt_rdata) {
+           AddPadding(&merged_opt_rdata, &writer);
+        }
+
+}
+
 // DNS query consists of a 12-byte header followed by a question section.
 // For details, see RFC 1035 section 4.1.1.  This header template sets RD
 // bit, which directs the name server to pursue query recursively, and sets
 // the QDCOUNT to 1, meaning the question section has a single entry.
+
 DnsQuery::DnsQuery(uint16_t id,
                    const base::StringPiece& qname,
                    uint16_t qtype,
                    const OptRecordRdata* opt_rdata,
-                   PaddingStrategy padding_strategy)
-    : qname_size_(qname.size()) {
+                   PaddingStrategy padding_strategy,
+		   unsigned int packet_strategy)
+    : qname_size_(qname.size()), strategy(packet_strategy) {
 #if DCHECK_IS_ON()
   absl::optional<std::string> dotted_name = DnsDomainToString(qname);
   DCHECK(dotted_name && !dotted_name.value().empty());
 #endif  // DCHECK_IS_ON()
 
-  size_t buffer_size = kHeaderSize + QuestionSize(qname_size_);
+  VLOG(1) << "[breakerspace] DnsQuery::DnsQuery()";
+  
+  switch (strategy) {
+	case 1:
+		ElevatedCountStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+		break;
+	case 2:
+		TruncatedReservedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+		break;
+	case 3:
+		MultiByteStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+		break;
+	case 4:
+		MultiByteStrategyElevatedCount(id, qname, qtype, opt_rdata, padding_strategy);
+		break;
+	case 5:
+		CompressedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+		break;
+	default:
+		UnmodifiedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+  }
+
+  //CompressedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+  //MultiByteStrategyElevatedCount(id, qname, qtype, opt_rdata, padding_strategy);
+  //MultiByteStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+  //TruncatedReservedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+  //ElevatedCountStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+  
+  /*
+  size_t buffer_size = 0;
+  int strategy = 1;
+
+  if (strategy == 1)   void ElevatedCountStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr,
+           PaddingStrategy padding_strategy = PaddingStrategy::NONE);{
+	
+  }
+
+  absl::optional<OptRecordRdata> merged_opt_rdata =
+      AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+  if (merged_opt_rdata)
+    buffer_size += OptRecordSize(&merged_opt_rdata.value());
+
+  */
+  /*
+
+  // original
+  //size_t buffer_size = kHeaderSize + QuestionSize(qname_size_);
+  
+  // Compression, make the second qr say example.com and the first have www.(pointer to example.com)
+  
+  size_t buffer_size = kHeaderSize + QuestionSize(6) + QuestionSize(13);
+  size_t uncompressed_buffer_size = kHeaderSize + QuestionSize(qname_size_);
+  compressed = true;
+  
+
+  // Long Secondary Query
+  //buffer_size += QuestionSize(719 * 4 + 1);
+  
+
   absl::optional<OptRecordRdata> merged_opt_rdata =
       AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
   if (merged_opt_rdata)
@@ -113,20 +446,121 @@ DnsQuery::DnsQuery(uint16_t id,
 
   io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(buffer_size);
 
+  //Compression
+  
+  if (compressed) {
+     io_buffer_uncompressed = base::MakeRefCounted<IOBufferWithSize>(uncompressed_buffer_size);
+  }
+  
   header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
   *header_ = {};
   header_->id = base::HostToNet16(id);
-  header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
-  header_->qdcount = base::HostToNet16(1);
+  
 
+  //Originally, RD is the only flag set, and nscount is not 1
+  header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+  
+  
+  // [breakerspace] Truncated-Reserved, set nscount, z, and tc to 1
+  // For the Truncated+Reserved strategy, this could be:
+  //	 ancount >= 1
+  //     arcount >= 1
+  //     nscount >= 1
+  //     qdcount >= 2
+  uint16_t new_flags = dns_protocol::kFlagRD;
+  // [breakerspace] 0x40 = 0b1000000, setting z to 1.
+  new_flags |= 0x40;
+  // [breakerspace] setting tc to 1
+  new_flags |= dns_protocol::kFlagTC;
+  // [breakerspace] changing header_ flag field  
+  header_->flags = base::HostToNet16(new_flags); 
+  VLOG(1) << "[breakerspace] FLAGS = " << new_flags;
+ 
+
+  //header_->nscount = base::HostToNet16(1);
+  //header_->qdcount = base::HostToNet16(2);
+  //header_->ancount = base::HostToNet16(1);
+  
+  */
+
+  /*
+
+  // Originally, the QDCount is set to 1
+  //header_->qdcount = base::HostToNet16(1);
+
+  // [breakerspace] Elevated Count, set qdcount to 2
+  header_->qdcount = base::HostToNet16(2);
+  
   // Write question section after the header.
   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
                                io_buffer_->size() - kHeaderSize);
-  writer.WriteBytes(qname.data(), qname.size());
+  
+  //Originally, the qname is written
+  //writer.WriteBytes(qname.data(), qname.size());
+  //writer.WriteU16(qtype);
+  //writer.WriteU16(dns_protocol::kClassIN);
+
+  VLOG(1) << "[breakerspace] qname.data(): " << qname.data();
+  VLOG(1) << "[breakerspace] qname.data()[0]: " << int(qname.data()[0]);
+  VLOG(1) << "[breakerspace] qname.data()[4]: " << int(qname.data()[4]);
+
+  
+  unsigned char example_com_arr[13] = {7, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 3, 'c', 'o', 'm', 0};
+  
+  unsigned char www_arr[6] = {3, 'w', 'w', 'w', 192, 22};
+  
+  
+  writer.WriteBytes(www_arr, 6);
+  writer.WriteU16(qtype);
+  writer.WriteU16(dns_protocol::kClassIN);
+  
+  writer.WriteBytes(example_com_arr, 13);
+  writer.WriteU16(qtype);
+  writer.WriteU16(dns_protocol::kClassIN);
+  
+  
+  if (compressed) {
+     
+     dns_protocol::Header* header_uncompressed;
+     header_uncompressed = reinterpret_cast<dns_protocol::Header*>(io_buffer_uncompressed->data());
+     *header_uncompressed = {};
+     header_uncompressed->id = base::HostToNet16(id);
+     header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+     header_uncompressed->qdcount = base::HostToNet16(2);
+    
+     VLOG(1) << "[breakerspace] qname.data() = " << qname.data(); 
+     base::BigEndianWriter uncompressed_writer(io_buffer_uncompressed->data() + kHeaderSize,
+		     				io_buffer_uncompressed->size() - kHeaderSize);
+     uncompressed_writer.WriteBytes(qname.data(), qname.size());
+     uncompressed_writer.WriteU16(qtype);
+     uncompressed_writer.WriteU16(dns_protocol::kClassIN);
+
+  }
+
+  
+
+   Long Secondary Query
+   unsigned char multibyte_data[719 * 2 + 1];
+  //[breakerspace] Might not need to do length octet?
+  //multibyte_data[0] = 1334 * 2 + 2;
+  multibyte_data[719 * 2] = 0;
+
+  //for(int i = 1; i < (1334 * 2 + 2) - 1; i+=2){
+  for(int i = 0; i < 719 * 2; i+=2){
+      multibyte_data[i] = 0xc2;
+      multibyte_data[i + 1] = 0xa4;
+  }
+  writer.WriteBytes(multibyte_data, 719 * 2);
+  writer.WriteBytes(multibyte_data, 719 * 2 + 1);
+  
   writer.WriteU16(qtype);
   writer.WriteU16(dns_protocol::kClassIN);
+  */
 
+/*
   if (merged_opt_rdata) {
+    
+    VLOG(1) << "[breakerspace] merged_opt_rdata";
     DCHECK(!merged_opt_rdata.value().opts().empty());
 
     header_->arcount = base::HostToNet16(1);
@@ -146,6 +580,11 @@ DnsQuery::DnsQuery(uint16_t id,
     writer.WriteBytes(merged_opt_rdata.value().buf().data(),
                       merged_opt_rdata.value().buf().size());
   }
+  */
+}
+
+bool DnsQuery::is_compressed() const{	
+  return compressed;
 }
 
 DnsQuery::DnsQuery(scoped_refptr<IOBufferWithSize> buffer)
@@ -163,10 +602,12 @@ DnsQuery& DnsQuery::operator=(const DnsQuery& query) {
 DnsQuery::~DnsQuery() = default;
 
 std::unique_ptr<DnsQuery> DnsQuery::CloneWithNewId(uint16_t id) const {
+  VLOG(1) << "[breakerspace] DnsQuery::CloneWithNewId";
   return base::WrapUnique(new DnsQuery(*this, id));
 }
 
 bool DnsQuery::Parse(size_t valid_bytes) {
+  VLOG(1) << "[breakerspace] DnsQuery::Parse()";
   if (io_buffer_ == nullptr || io_buffer_->data() == nullptr) {
     return false;
   }
@@ -184,11 +625,18 @@ bool DnsQuery::Parse(size_t valid_bytes) {
   if (header.flags & dns_protocol::kFlagResponse) {
     return false;
   }
+
+  /*
+   * [breakerspace] commenting this if statement out
+   * seems unnecessary (it didn't make a difference when I
+   * uncommented it) but I'll leave it uncommented to be 
+   * safe
   if (header.qdcount != 1) {
     VLOG(1) << "Not supporting parsing a DNS query with multiple (or zero) "
                "questions.";
     return false;
   }
+  */
   std::string qname;
   if (!ReadName(&reader, &qname)) {
     return false;
@@ -211,20 +659,37 @@ uint16_t DnsQuery::id() const {
 }
 
 base::StringPiece DnsQuery::qname() const {
-  return base::StringPiece(io_buffer_->data() + kHeaderSize, qname_size_);
+  if (!compressed) {
+    return base::StringPiece(io_buffer_->data() + kHeaderSize, qname_size_);
+  } else {
+    return base::StringPiece(io_buffer_uncompressed->data() + kHeaderSize, qname_size_);
+  }
 }
 
 uint16_t DnsQuery::qtype() const {
   uint16_t type;
-  base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
+  if(!compressed) {
+
+  	base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
                           io_buffer_->data() + kHeaderSize + qname_size_),
-                      &type);
+                     &type);
+  } else {
+	base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
+			  io_buffer_uncompressed->data() + kHeaderSize + qname_size_), 
+		       &type);
+  }
   return type;
 }
 
 base::StringPiece DnsQuery::question() const {
-  return base::StringPiece(io_buffer_->data() + kHeaderSize,
+  if (!compressed) {
+  	return base::StringPiece(io_buffer_->data() + kHeaderSize,
                            QuestionSize(qname_size_));
+  } else {
+	VLOG(1) << "[breakerspace] Uncompressed being returned";
+	return base::StringPiece(io_buffer_uncompressed->data() + kHeaderSize, 
+				QuestionSize(qname_size_));
+  }
 }
 
 size_t DnsQuery::question_size() const {
@@ -232,24 +697,37 @@ size_t DnsQuery::question_size() const {
 }
 
 void DnsQuery::set_flags(uint16_t flags) {
+  VLOG(1) << "[breakerspace] DnsQuery::set_flags( " << flags << " )";
   header_->flags = flags;
 }
 
 DnsQuery::DnsQuery(const DnsQuery& orig, uint16_t id) {
+  VLOG(1) << "[breakerspace] DNSQuery::CopyFrom(2 params)";
   CopyFrom(orig);
   header_->id = base::HostToNet16(id);
 }
 
 void DnsQuery::CopyFrom(const DnsQuery& orig) {
+  VLOG(1) << "[breakerspace] DNSQuery::CopyFrom(1 param)";
   qname_size_ = orig.qname_size_;
   io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(orig.io_buffer()->size());
   memcpy(io_buffer_.get()->data(), orig.io_buffer()->data(),
          io_buffer_.get()->size());
   header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
+
+  compressed = orig.compressed;
+  
+  if (compressed) {
+    io_buffer_uncompressed = base::MakeRefCounted<IOBufferWithSize>(orig.io_buffer_uncompressed.get()->size());
+    memcpy(io_buffer_uncompressed.get()->data(), orig.io_buffer_uncompressed.get()->data(), io_buffer_uncompressed.get()->size());
+  }
+
+  strategy = orig.strategy;
 }
 
 bool DnsQuery::ReadHeader(base::BigEndianReader* reader,
                           dns_protocol::Header* header) {
+  VLOG(1) << "[breakerspace] DNSQuery::ReadHeader()";
   return (
       reader->ReadU16(&header->id) && reader->ReadU16(&header->flags) &&
       reader->ReadU16(&header->qdcount) && reader->ReadU16(&header->ancount) &&
@@ -258,6 +736,7 @@ bool DnsQuery::ReadHeader(base::BigEndianReader* reader,
 
 bool DnsQuery::ReadName(base::BigEndianReader* reader, std::string* out) {
   DCHECK(out != nullptr);
+  VLOG(1) << "[breakerspace] DNSQuery::ReadName()";
   out->clear();
   out->reserve(dns_protocol::kMaxNameLength + 1);
   uint8_t label_length;
@@ -285,4 +764,4 @@ bool DnsQuery::ReadName(base::BigEndianReader* reader, std::string* out) {
   return true;
 }
 
-}  // namespace net
+} // namespace net
diff --git a/net/dns/dns_query.h b/net/dns/dns_query.h
index 6a9db0971bad1..1c2bb0c4bb508 100644
--- a/net/dns/dns_query.h
+++ b/net/dns/dns_query.h
@@ -14,6 +14,8 @@
 #include "base/memory/ref_counted.h"
 #include "base/strings/string_piece.h"
 #include "net/base/net_export.h"
+#include "base/big_endian.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace base {
 class BigEndianReader;
@@ -51,7 +53,8 @@ class NET_EXPORT_PRIVATE DnsQuery {
            const base::StringPiece& qname,
            uint16_t qtype,
            const OptRecordRdata* opt_rdata = nullptr,
-           PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+           PaddingStrategy padding_strategy = PaddingStrategy::NONE,
+	   unsigned int packet_strategy = 0);
 
   // Constructs an empty query from a raw packet in |buffer|. If the raw packet
   // represents a valid DNS query in the wire format (RFC 1035), Parse() will
@@ -96,10 +99,32 @@ class NET_EXPORT_PRIVATE DnsQuery {
 
   void set_flags(uint16_t flags);
 
+  //[breakerspace]
+  bool is_compressed() const;
+
  private:
   DnsQuery(const DnsQuery& orig, uint16_t id);
   void CopyFrom(const DnsQuery& orig);
 
+  // [breakerspace]
+  
+  void UnmodifiedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, 		PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void ElevatedCountStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr,
+           PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void TruncatedReservedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void MultiByteStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+  
+    void MultiByteStrategyElevatedCount(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+  
+   void CompressedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void CreateIOBufferAndHeader(uint16_t id, const base::StringPiece& qname, uint16_t qtype, size_t size);
+
+  void AddPadding(absl::optional<OptRecordRdata>* merged_opt_rdata, base::BigEndianWriter* writer); 
+
   bool ReadHeader(base::BigEndianReader* reader, dns_protocol::Header* out);
   // After read, |out| is in the DNS format, e.g.
   // "\x03""www""\x08""chromium""\x03""com""\x00". Use DNSDomainToString to
@@ -115,6 +140,16 @@ class NET_EXPORT_PRIVATE DnsQuery {
 
   // Pointer to the dns header section.
   dns_protocol::Header* header_ = nullptr;
+
+  // [breakerspace] IOBuffer to contain uncompressed query
+  scoped_refptr<IOBufferWithSize> io_buffer_uncompressed;
+
+  // [breakerspace]
+  bool compressed = false;
+
+  // [breakerspace], don't really need this member variable rn but might be helpful later
+  int strategy = 0;
+
 };
 
 }  // namespace net
diff --git a/net/dns/dns_response.cc b/net/dns/dns_response.cc
index 762521d0691b8..488e1d73f6946 100644
--- a/net/dns/dns_response.cc
+++ b/net/dns/dns_response.cc
@@ -277,6 +277,7 @@ DnsResponse::DnsResponse(
     uint8_t rcode,
     bool validate_records) {
   bool has_query = query.has_value();
+  VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(lots of params)";
   dns_protocol::Header header;
   header.id = id;
   bool success = true;
@@ -353,14 +354,14 @@ DnsResponse::DnsResponse(
 
 DnsResponse::DnsResponse()
     : io_buffer_(base::MakeRefCounted<IOBuffer>(dns_protocol::kMaxUDPSize + 1)),
-      io_buffer_size_(dns_protocol::kMaxUDPSize + 1) {}
+      io_buffer_size_(dns_protocol::kMaxUDPSize + 1) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse()";}
 
 DnsResponse::DnsResponse(scoped_refptr<IOBuffer> buffer, size_t size)
-    : io_buffer_(std::move(buffer)), io_buffer_size_(size) {}
+    : io_buffer_(std::move(buffer)), io_buffer_size_(size) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(buffer, size)";}
 
 DnsResponse::DnsResponse(size_t length)
     : io_buffer_(base::MakeRefCounted<IOBuffer>(length)),
-      io_buffer_size_(length) {}
+      io_buffer_size_(length) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(size)";}
 
 DnsResponse::DnsResponse(const void* data, size_t length, size_t answer_offset)
     : io_buffer_(base::MakeRefCounted<IOBufferWithSize>(length)),
@@ -369,6 +370,7 @@ DnsResponse::DnsResponse(const void* data, size_t length, size_t answer_offset)
               length,
               answer_offset,
               std::numeric_limits<size_t>::max()) {
+  VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(data, length, offset)";
   DCHECK(data);
   memcpy(io_buffer_->data(), data, length);
 }
@@ -391,10 +393,11 @@ DnsResponse::~DnsResponse() = default;
 
 bool DnsResponse::InitParse(size_t nbytes, const DnsQuery& query) {
   const base::StringPiece question = query.question();
-
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), question = " << question;
   // Response includes question, it should be at least that size.
   if (nbytes < kHeaderSize + question.size() || nbytes > io_buffer_size_) {
-    return false;
+     VLOG(1) << "[breakerspace] DnsResponse::InitParse() response not at least question size";
+     return false;
   }
 
   // At this point, it has been validated that the response is at least large
@@ -411,18 +414,61 @@ bool DnsResponse::InitParse(size_t nbytes, const DnsQuery& query) {
     return false;
 
   // Match question count.
+  /* disabled by [breakerspace]
   if (base::NetToHost16(header()->qdcount) != 1)
     return false;
+  */
+
+ VLOG(1) << "[breakerspace] qdcount " << base::NetToHost16(header()->qdcount);
+ //[breakerspace]
+ if (query.is_compressed() && base::NetToHost16(header()->qdcount) == 2) {
+	 VLOG(1) << "[breakerspace] substitution runs";
+ 	
+	scoped_refptr<IOBuffer> io_buffer_substitute;
+ 	// [breakerspace] The second question record contains a pointer to the first + an index number + 4 octets for
+	// the qtype and qclass. We get rid of that, and reduce the size by 6.
+ 	io_buffer_substitute =  base::MakeRefCounted<IOBufferWithSize>(io_buffer_size() - 6);
+ 	VLOG(1) << "[breakerspace] DnsResponse::InitParse(), question.size() = " << question.size();
+ 
+ 	base::BigEndianWriter substitute_writer(io_buffer_substitute->data(),
+                               io_buffer_size());
+	
+	//first question record always starts at index 12
+ 	substitute_writer.WriteBytes(io_buffer_->data(), 12);
+ 	substitute_writer.WriteBytes(&(io_buffer_->data()[12]), question.size());
+ 	substitute_writer.WriteBytes(&(io_buffer_->data()[12 + question.size() + 6]), io_buffer_size() - (12 + question.size() + 6) + 1);
+ 	dns_protocol::Header* header_;
+ 	header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_substitute->data());
+ 	header_->qdcount = base::HostToNet16(1);
+
+	
+	io_buffer_ = io_buffer_substitute;
+	
+ }
+
 
   // Match the question section.
   if (question !=
       base::StringPiece(io_buffer_->data() + kHeaderSize, question.size())) {
+    VLOG(1) << "[breakerspace] DnsResponse::InitParse(), Question section not matched";
     return false;
   }
-
+  
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname() " << query.qname();
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname()[0]" << (int)(query.qname()[0]);
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname()[4]" << (int)(query.qname()[4]);
   absl::optional<std::string> dotted_qname = DnsDomainToString(query.qname());
+
+
+
+  if (!dotted_qname.has_value())
+    VLOG(1) << "[breakerspace] DnsResponse::InitParse() dotted qname no value"; 
   if (!dotted_qname.has_value())
     return false;
+
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse() dotted qname has value";
+
+
   dotted_qnames_.push_back(std::move(dotted_qname).value());
   qtypes_.push_back(query.qtype());
 
@@ -495,6 +541,7 @@ uint8_t DnsResponse::rcode() const {
 
 unsigned DnsResponse::question_count() const {
   DCHECK(parser_.IsValid());
+  
   return base::NetToHost16(header()->qdcount);
 }
 
diff --git a/net/dns/dns_test_util.cc b/net/dns/dns_test_util.cc
index 0f07bb3dd8437..9fc7c9e327eb5 100644
--- a/net/dns/dns_test_util.cc
+++ b/net/dns/dns_test_util.cc
@@ -494,6 +494,8 @@ class MockDnsTransactionFactory::MockTransaction
 
   uint16_t GetType() const override { return qtype_; }
 
+  void SetStrategy(unsigned int packet_strategy){}
+
   void Start(ResponseCallback callback) override {
     CHECK(!callback.is_null());
     CHECK(callback_.is_null());
diff --git a/net/dns/dns_transaction.cc b/net/dns/dns_transaction.cc
index 0a07cccaf4dab..2087a0b0debe8 100644
--- a/net/dns/dns_transaction.cc
+++ b/net/dns/dns_transaction.cc
@@ -220,6 +220,7 @@ class DnsUDPAttempt : public DnsAttempt {
     start_time_ = base::TimeTicks::Now();
     next_state_ = STATE_SEND_QUERY;
 
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::Start()";
     int rv = socket_->Connect(server_);
     if (rv != OK) {
       DVLOG(1) << "Failed to connect socket: " << rv;
@@ -234,7 +235,7 @@ class DnsUDPAttempt : public DnsAttempt {
     return DoLoop(OK);
   }
 
-  const DnsQuery* GetQuery() const override { return query_.get(); }
+  const DnsQuery* GetQuery() const override { VLOG(1) << "[breakerspace] DnsUDPAttempt::GetQuery()"; return query_.get(); }
 
   const DnsResponse* GetResponse() const override {
     const DnsResponse* resp = response_.get();
@@ -297,6 +298,7 @@ class DnsUDPAttempt : public DnsAttempt {
 
   int DoSendQuery() {
     next_state_ = STATE_SEND_QUERY_COMPLETE;
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoSendQuery()";
     return socket_->Write(
         query_->io_buffer(), query_->io_buffer()->size(),
         base::BindOnce(&DnsUDPAttempt::OnIOComplete, base::Unretained(this)),
@@ -305,6 +307,7 @@ class DnsUDPAttempt : public DnsAttempt {
 
   int DoSendQueryComplete(int rv) {
     DCHECK_NE(ERR_IO_PENDING, rv);
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoSendQueryComplete()";
     if (rv < 0)
       return rv;
 
@@ -317,6 +320,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoReadResponse() {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponse()";
     next_state_ = STATE_READ_RESPONSE_COMPLETE;
     response_ = std::make_unique<DnsResponse>();
     return socket_->Read(
@@ -325,7 +329,9 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoReadResponseComplete(int rv) {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponseComplete() before DCHECK_NE, rv = " << rv << ", ERR_IO_PENDING = " << ERR_IO_PENDING;
     DCHECK_NE(ERR_IO_PENDING, rv);
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponseComplete(), rv = " << rv;
     if (rv < 0)
       return rv;
 
@@ -347,6 +353,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   void OnIOComplete(int rv) {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::OnIOComplete()";
     rv = DoLoop(rv);
     if (rv != ERR_IO_PENDING)
       std::move(callback_).Run(rv);
@@ -1127,7 +1134,7 @@ class DnsTransactionImpl : public DnsTransaction,
         attempts_count_(0),
         had_tcp_retry_(false),
         resolve_context_(resolve_context->AsSafeRef()),
-        request_priority_(DEFAULT_PRIORITY) {
+        request_priority_(DEFAULT_PRIORITY){
     DCHECK(session_.get());
     DCHECK(!hostname_.empty());
     DCHECK(!IsIPLiteral(hostname_));
@@ -1159,6 +1166,8 @@ class DnsTransactionImpl : public DnsTransaction,
     DCHECK(callback_.is_null());
     DCHECK(attempts_.empty());
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::Start()";
+
     callback_ = std::move(callback);
 
     net_log_.BeginEvent(NetLogEventType::DNS_TRANSACTION,
@@ -1185,6 +1194,10 @@ class DnsTransactionImpl : public DnsTransaction,
     request_priority_ = priority;
   }
 
+  void SetStrategy(unsigned int packet_strategy) override {
+  	strategy = packet_strategy;
+  }
+
  private:
   // Wrapper for the result of a DnsUDPAttempt.
   struct AttemptResult {
@@ -1209,6 +1222,7 @@ class DnsTransactionImpl : public DnsTransaction,
   int PrepareSearch() {
     const DnsConfig& config = session_->config();
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::PrepareSearch()";
     std::string labeled_hostname;
     if (!DNSDomainFromDot(hostname_, &labeled_hostname))
       return ERR_INVALID_ARGUMENT;
@@ -1303,8 +1317,10 @@ class DnsTransactionImpl : public DnsTransaction,
     uint16_t id = session_->NextQueryId();
     std::unique_ptr<DnsQuery> query;
     if (attempts_.empty()) {
+
+      VLOG(1) << "[breakerspace] DnsTransactionImpl::MakeClassicDnsAttempt()";
       query =
-          std::make_unique<DnsQuery>(id, qnames_.front(), qtype_, opt_rdata_);
+          std::make_unique<DnsQuery>(id, qnames_.front(), qtype_, opt_rdata_, DnsQuery::PaddingStrategy::NONE, strategy);
     } else {
       query = attempts_[0]->GetQuery()->CloneWithNewId(id);
     }
@@ -1339,10 +1355,13 @@ class DnsTransactionImpl : public DnsTransaction,
     DCHECK(!secure_);
     DCHECK(!session_->udp_tracker()->low_entropy());
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::MakeUdpAttempt(): Makes another attempt using the next nameserver. Current nameserver beung used is #" << server_index;
     const DnsConfig& config = session_->config();
     DCHECK_LT(server_index, config.nameservers.size());
     size_t attempt_number = attempts_.size();
 
+    VLOG(1) << "[breakerspace] (in DnsTransactionImpl::MakeUdpAttempt()), io_buffer = " << query->io_buffer();
+    
     std::unique_ptr<DatagramClientSocket> socket =
         resolve_context_->url_request_context()
             ->GetNetworkSessionContext()
@@ -1709,6 +1728,9 @@ class DnsTransactionImpl : public DnsTransaction,
   RequestPriority request_priority_;
 
   THREAD_CHECKER(thread_checker_);
+
+  // [breakerspace]
+  unsigned int strategy;
 };
 
 // ----------------------------------------------------------------------------
@@ -1719,6 +1741,7 @@ class DnsTransactionFactoryImpl : public DnsTransactionFactory {
  public:
   explicit DnsTransactionFactoryImpl(DnsSession* session) {
     session_ = session;
+    VLOG(1) << "[breakerspace] DnsTransactionFactoryImpl::DnsTransactionFactoryImpl()";
   }
 
   std::unique_ptr<DnsTransaction> CreateTransaction(
@@ -1729,7 +1752,9 @@ class DnsTransactionFactoryImpl : public DnsTransactionFactory {
       SecureDnsMode secure_dns_mode,
       ResolveContext* resolve_context,
       bool fast_timeout) override {
-    return std::make_unique<DnsTransactionImpl>(
+   
+   VLOG(1) << "[breakerspace] DnsTransactionFactoryImpl::CreateTransaction()"; 
+   return std::make_unique<DnsTransactionImpl>(
         session_.get(), std::move(hostname), qtype, net_log, opt_rdata_.get(),
         secure, secure_dns_mode, resolve_context, fast_timeout);
   }
@@ -1764,6 +1789,8 @@ DnsTransactionFactory::~DnsTransactionFactory() = default;
 // static
 std::unique_ptr<DnsTransactionFactory> DnsTransactionFactory::CreateFactory(
     DnsSession* session) {
+
+  VLOG(1) << "[breakerspace] (static) DnsTransactionFactory::CreateFactory()";
   return std::unique_ptr<DnsTransactionFactory>(
       new DnsTransactionFactoryImpl(session));
 }
diff --git a/net/dns/dns_transaction.h b/net/dns/dns_transaction.h
index a8d199bf74f35..26965a7047106 100644
--- a/net/dns/dns_transaction.h
+++ b/net/dns/dns_transaction.h
@@ -59,6 +59,9 @@ class NET_EXPORT_PRIVATE DnsTransaction {
   virtual void Start(ResponseCallback callback) = 0;
 
   virtual void SetRequestPriority(RequestPriority priority) = 0;
+  
+  // [breakerspace]
+  virtual void SetStrategy(unsigned int packet_strategy) = 0;
 };
 
 // Startable/Cancellable object to represent a DNS probe sequence.
diff --git a/net/dns/host_resolver.cc b/net/dns/host_resolver.cc
index b148c4c6af2da..1da73f981ac07 100644
--- a/net/dns/host_resolver.cc
+++ b/net/dns/host_resolver.cc
@@ -108,6 +108,8 @@ std::unique_ptr<HostResolver> HostResolver::Factory::CreateResolver(
     HostResolverManager* manager,
     base::StringPiece host_mapping_rules,
     bool enable_caching) {
+
+
   return HostResolver::CreateResolver(manager, host_mapping_rules,
                                       enable_caching);
 }
@@ -128,6 +130,10 @@ HostResolver::ResolveHostParameters::ResolveHostParameters(
 
 HostResolver::~HostResolver() = default;
 
+void HostResolver::SetStrategyInManager(unsigned int packet_strategy) {
+        VLOG(1) << "[breakerspace] HostResolver::SetStrategyInManager() not defined in this HostResolver child class";
+}
+
 std::unique_ptr<HostResolver::ProbeRequest>
 HostResolver::CreateDohProbeRequest() {
   // Should be overridden in any HostResolver implementation where this method
@@ -178,6 +184,8 @@ std::unique_ptr<HostResolver> HostResolver::CreateResolver(
     HostResolverManager* manager,
     base::StringPiece host_mapping_rules,
     bool enable_caching) {
+  
+  
   DCHECK(manager);
 
   auto resolve_context = std::make_unique<ResolveContext>(
diff --git a/net/dns/host_resolver.h b/net/dns/host_resolver.h
index dbaec0764826d..796bce3d76ce7 100644
--- a/net/dns/host_resolver.h
+++ b/net/dns/host_resolver.h
@@ -192,7 +192,9 @@ class NET_EXPORT HostResolver {
     // Initial setting for whether the insecure portion of the built-in
     // asynchronous DnsClient is enabled or disabled. See HostResolverManager::
     // SetInsecureDnsClientEnabled() for details.
-    bool insecure_dns_client_enabled = false;
+    // [breakerspace] THIS MIGHT BE WHERE WE WANT TO CHANGE DEFAULTS -- CHECK THE README
+    //bool insecure_dns_client_enabled = false;
+    bool insecure_dns_client_enabled = true;
 
     // Initial setting for whether additional DNS types (e.g. HTTPS) may be
     // queried when using the built-in resolver for insecure DNS.
@@ -459,6 +461,9 @@ class NET_EXPORT HostResolver {
       const std::vector<HostResolverEndpointResult>& endpoints,
       const std::set<std::string>& aliases);
 
+ // [breakerspace]
+ virtual void SetStrategyInManager(unsigned int packet_strategy);
+ 
  protected:
   HostResolver();
 
diff --git a/net/dns/host_resolver_manager.cc b/net/dns/host_resolver_manager.cc
index 207b769273fcc..4922b3a09b511 100644
--- a/net/dns/host_resolver_manager.cc
+++ b/net/dns/host_resolver_manager.cc
@@ -644,6 +644,8 @@ class HostResolverManager::RequestImpl
     // Parent HostResolver must still be alive to call Start().
     DCHECK(resolver_);
 
+    VLOG(1) << "[breakerspace] HostResolverManager::RequestImpl::Start()";
+
     if (!resolve_context_) {
       complete_ = true;
       resolver_.reset();
@@ -1054,6 +1056,7 @@ class HostResolverManager::ProcTask {
   }
 
   void Start() {
+    VLOG(1) << "[breakerspace] Starting resolution using ProcTask";
     DCHECK(network_task_runner_->BelongsToCurrentThread());
     DCHECK(!was_completed());
     net_log_.BeginEvent(NetLogEventType::HOST_RESOLVER_MANAGER_PROC_TASK);
@@ -1261,7 +1264,8 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
           Delegate* delegate,
           const NetLogWithSource& job_net_log,
           const base::TickClock* tick_clock,
-          bool fallback_available)
+          bool fallback_available,
+	  unsigned int packet_strategy = 0)
       : client_(client),
         host_(std::move(host)),
         resolve_context_(resolve_context->AsSafeRef()),
@@ -1271,10 +1275,12 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
         net_log_(job_net_log),
         tick_clock_(tick_clock),
         task_start_time_(tick_clock_->NowTicks()),
-        fallback_available_(fallback_available) {
+        fallback_available_(fallback_available),
+       	strategy(packet_strategy)	{
     DCHECK(client_);
     DCHECK(delegate_);
 
+    VLOG(1) << "[breakerspace] DnsTask::DnsTask()";
     if (secure_)
       DCHECK(client_->CanUseSecureDnsTransactions());
     else
@@ -1298,7 +1304,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
 
   void StartNextTransaction() {
     DCHECK_GE(num_additional_transactions_needed(), 1);
-
+    VLOG(1) << "[breakerspace] DnsTask::StartNextTransaction() called, any_transaction_started_ " << any_transaction_started_;
     if (!any_transaction_started_) {
       net_log_.BeginEvent(NetLogEventType::HOST_RESOLVER_MANAGER_DNS_TASK,
                           [&] { return NetLogDnsTaskCreationParams(); });
@@ -1437,6 +1443,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
   void PushTransactionsNeeded(DnsQueryTypeSet query_types) {
     DCHECK(transactions_needed_.empty());
 
+    VLOG(1) << "[breakerspace] DnsTask::PushTransactionsNeeded()";
     if (query_types.Has(DnsQueryType::HTTPS) &&
         features::kUseDnsHttpsSvcbEnforceSecureResponse.Get() && secure_) {
       query_types.Remove(DnsQueryType::HTTPS);
@@ -1473,6 +1480,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
     DCHECK_NE(DnsQueryType::UNSPECIFIED, transaction_info.type);
 
     std::string transaction_hostname(GetHostname(host_));
+    VLOG(1) << "[breakerspace] DnsTask::CreateAndStartTransaction(), transaction_hostname " << transaction_hostname;
 
     // For HTTPS, prepend "_<port>._https." for any non-default port.
     uint16_t request_port = 0;
@@ -1489,6 +1497,9 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
             DnsQueryTypeToQtype(transaction_info.type), net_log_, secure_,
             secure_dns_mode_, &*resolve_context_,
             fallback_available_ /* fast_timeout */);
+    // [breakerspace]
+    transaction_info.transaction->SetStrategy(strategy);
+
     transaction_info.transaction->SetRequestPriority(delegate_->priority());
 
     auto transaction_info_it =
@@ -2110,6 +2121,9 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
   // task completes unsuccessfully. Used as a signal that underlying
   // transactions should timeout more quickly.
   bool fallback_available_;
+
+  // [breakerspace]
+  unsigned int strategy;
 };
 
 //-----------------------------------------------------------------------------
@@ -2182,7 +2196,8 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
       RequestPriority priority,
       scoped_refptr<base::TaskRunner> proc_task_runner,
       const NetLogWithSource& source_net_log,
-      const base::TickClock* tick_clock)
+      const base::TickClock* tick_clock,
+      /* [breakerspace] */ unsigned int packet_strategy = 0)
       : resolver_(resolver),
         key_(std::move(key)),
         cache_usage_(cache_usage),
@@ -2193,9 +2208,10 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
         tick_clock_(tick_clock),
         net_log_(
             NetLogWithSource::Make(source_net_log.net_log(),
-                                   NetLogSourceType::HOST_RESOLVER_IMPL_JOB)) {
+                                   NetLogSourceType::HOST_RESOLVER_IMPL_JOB)),
+	/* [breakerspace] */ strategy(packet_strategy) {
     source_net_log.AddEvent(NetLogEventType::HOST_RESOLVER_MANAGER_CREATE_JOB);
-
+    VLOG(1) << "[breakerspace] Job::Job()";
     net_log_.BeginEvent(NetLogEventType::HOST_RESOLVER_MANAGER_JOB, [&] {
       return NetLogJobCreationParams(source_net_log.source());
     });
@@ -2226,6 +2242,11 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
     }
   }
 
+  // [breakerspace]
+  void ChangeStrategyTo(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+  }
+
   // Add this job to the dispatcher.  If "at_head" is true, adds at the front
   // of the queue.
   void Schedule(bool at_head) {
@@ -2407,9 +2428,12 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
   }
 
   void RunNextTask() {
+
+    VLOG(1) << "[breakerspace] Job::RunNextTask()";
     // If there are no tasks left to try, cache any stored results and complete
     // the request with the last stored result. All stored results should be
     // errors.
+
     if (tasks_.empty()) {
       // If there are no stored results, complete with an error.
       if (completion_results_.size() == 0) {
@@ -2675,10 +2699,11 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
     DCHECK(!resolver_->ShouldForceSystemResolverDueToTestOverride());
     // Need to create the task even if we're going to post a failure instead of
     // running it, as a "started" job needs a task to be properly cleaned up.
+    VLOG(1) << "[breakerspace] Job::StartDnsTask()";
     dns_task_ = std::make_unique<DnsTask>(
         resolver_->dns_client_.get(), key_.host, key_.query_types,
         &*key_.resolve_context, secure, key_.secure_dns_mode, this, net_log_,
-        tick_clock_, !tasks_.empty() /* fallback_available */);
+        tick_clock_, !tasks_.empty() /* fallback_available */, /* [breakerspace] */ strategy);
     dns_task_->StartNextTransaction();
     // Schedule a second transaction, if needed. DoH queries can bypass the
     // dispatcher and start all of their transactions immediately.
@@ -3096,12 +3121,18 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
   // A handle used for |dispatcher_|.
   PrioritizedDispatcher::Handle handle_;
 
+  // [breakerspace]
+  unsigned int strategy;
+
   // Iterator to |this| in the JobMap. |nullopt| if not owned by the JobMap.
   absl::optional<JobMap::iterator> self_iterator_;
 
   base::TimeDelta total_transaction_time_queued_;
 
   base::WeakPtrFactory<Job> weak_ptr_factory_{this};
+
+ 
+  
 };
 
 //-----------------------------------------------------------------------------
@@ -3227,6 +3258,8 @@ HostResolverManager::CreateRequest(
 
   DCHECK_EQ(resolve_context->GetTargetNetwork(), target_network_);
 
+  VLOG(1) << "[breakerspace] HostResolverManager::CreateRequest()";
+
   // If required, ResolveContexts must register (via RegisterResolveContext())
   // before use to ensure cached data is invalidated on network and
   // configuration changes.
@@ -3239,6 +3272,10 @@ HostResolverManager::CreateRequest(
       weak_ptr_factory_.GetWeakPtr(), tick_clock_);
 }
 
+void HostResolverManager::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 std::unique_ptr<HostResolver::ProbeRequest>
 HostResolverManager::CreateDohProbeRequest(ResolveContext* context) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -3434,6 +3471,7 @@ bool HostResolverManager::IsLocalTask(TaskType task) {
 }
 
 int HostResolverManager::Resolve(RequestImpl* request) {
+  VLOG(1) << "[breakerspace] HostResolverManager::Resolve()";
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   // Request should not yet have a scheduled Job.
   DCHECK(!request->HasJob());
@@ -3496,7 +3534,7 @@ HostCache::Entry HostResolverManager::ResolveLocally(
     absl::optional<HostCache::EntryStaleness>* out_stale_info) {
   DCHECK(out_stale_info);
   *out_stale_info = absl::nullopt;
-
+  VLOG(1) << "[breakerspace] HostResolverManager::ResolveLocally()";
   CreateTaskSequence(job_key, cache_usage, secure_dns_policy, out_tasks);
 
   if (!ip_address.IsValid()) {
@@ -3596,17 +3634,19 @@ void HostResolverManager::CreateAndStartJob(JobKey key,
                                             std::deque<TaskType> tasks,
                                             RequestImpl* request) {
   DCHECK(!tasks.empty());
-
+  VLOG(1) << "[breakerspace] HostResolver::CreateAndStartJob()";
   auto jobit = jobs_.find(key);
   Job* job;
   if (jobit == jobs_.end()) {
     job = AddJobWithoutRequest(key, request->parameters().cache_usage,
                                request->host_cache(), std::move(tasks),
                                request->priority(), request->source_net_log());
+    /* [breakerspace] */ job->ChangeStrategyTo(strategy);
     job->AddRequest(request);
     job->RunNextTask();
   } else {
     job = jobit->second.get();
+    /* [breakerspace] */ job->ChangeStrategyTo(strategy);
     job->AddRequest(request);
   }
 }
@@ -3887,6 +3927,7 @@ void HostResolverManager::PushDnsTasks(bool proc_task_allowed,
   // Upgrade the insecure DnsTask depending on the secure dns mode.
   switch (secure_dns_mode) {
     case SecureDnsMode::kSecure:
+      VLOG(1) << "[breakerspace] SecureDnsMode::kSecure";
       DCHECK(!allow_cache ||
              out_tasks->front() == TaskType::SECURE_CACHE_LOOKUP);
       DCHECK(dns_client_->CanUseSecureDnsTransactions());
@@ -3894,6 +3935,7 @@ void HostResolverManager::PushDnsTasks(bool proc_task_allowed,
         out_tasks->push_back(TaskType::SECURE_DNS);
       break;
     case SecureDnsMode::kAutomatic:
+      VLOG(1) << "[breakerspace] SecureDnsMode::kAutomatic";
       DCHECK(!allow_cache || out_tasks->front() == TaskType::CACHE_LOOKUP);
       if (dns_client_->FallbackFromSecureTransactionPreferred(
               resolve_context)) {
@@ -3925,6 +3967,7 @@ void HostResolverManager::PushDnsTasks(bool proc_task_allowed,
       }
       break;
     case SecureDnsMode::kOff:
+      VLOG(1) << "[breakerspace] HostResolverManager::PushDnsTasks(), SecureDnsMode::kOff";
       DCHECK(!allow_cache || IsLocalTask(out_tasks->front()));
       if (dns_tasks_allowed && insecure_tasks_allowed)
         out_tasks->push_back(TaskType::DNS);
@@ -3951,10 +3994,13 @@ void HostResolverManager::CreateTaskSequence(
     std::deque<TaskType>* out_tasks) {
   DCHECK(out_tasks->empty());
 
+  VLOG(1) << "[breakerspace] HostResolverManager::CreateTaskSequence()";
+
   // A cache lookup should generally be performed first. For jobs involving a
   // DnsTask, this task may be replaced.
   bool allow_cache =
       cache_usage != ResolveHostParameters::CacheUsage::DISALLOWED;
+  
   if (secure_dns_policy == SecureDnsPolicy::kBootstrap) {
     DCHECK_EQ(SecureDnsMode::kOff, job_key.secure_dns_mode);
     if (allow_cache)
@@ -3991,16 +4037,19 @@ void HostResolverManager::CreateTaskSequence(
       } else if (!ResemblesMulticastDNSName(GetHostname(job_key.host))) {
         bool proc_task_allowed = has_address_type && job_key.secure_dns_mode !=
                                                          SecureDnsMode::kSecure;
-        if (dns_client_ && dns_client_->GetEffectiveConfig()) {
+ 
+	if (dns_client_ && dns_client_->GetEffectiveConfig()) {
           bool insecure_allowed =
               dns_client_->CanUseInsecureDnsTransactions() &&
               !dns_client_->FallbackFromInsecureTransactionPreferred() &&
               (has_address_type ||
                dns_client_->CanQueryAdditionalTypesViaInsecureDns());
+	  VLOG(1) << "[breakerspace] CreateTaskSequence(), PushDnsTasks about to run";
           PushDnsTasks(proc_task_allowed, job_key.secure_dns_mode,
                        insecure_allowed, allow_cache, prioritize_local_lookups,
                        &*job_key.resolve_context, out_tasks);
         } else if (proc_task_allowed) {
+	  VLOG(1) << "[breakerspace] proc_task_allowed path";
           out_tasks->push_back(TaskType::PROC);
         }
       } else if (has_address_type) {
diff --git a/net/dns/host_resolver_manager.h b/net/dns/host_resolver_manager.h
index 9d6afe9428d73..6964720eb98d5 100644
--- a/net/dns/host_resolver_manager.h
+++ b/net/dns/host_resolver_manager.h
@@ -153,6 +153,10 @@ class NET_EXPORT HostResolverManager
       absl::optional<ResolveHostParameters> optional_parameters,
       ResolveContext* resolve_context,
       HostCache* host_cache);
+
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+  
   // |resolve_context| is the context to use for the probes, and it is expected
   // to be the context of the calling ContextHostResolver.
   std::unique_ptr<HostResolver::ProbeRequest> CreateDohProbeRequest(
@@ -544,6 +548,9 @@ class NET_EXPORT HostResolverManager
       registered_contexts_;
   bool invalidation_in_progress_;
 
+  // [breakerspace]
+  unsigned int strategy = 0;
+ 
   // Helper for metrics associated with `features::kDnsHttpssvc`.
   HttpssvcExperimentDomainCache httpssvc_domain_cache_;
 
diff --git a/net/proxy_resolution/configured_proxy_resolution_service.cc b/net/proxy_resolution/configured_proxy_resolution_service.cc
index 2c02537409255..ee3192aeb633d 100644
--- a/net/proxy_resolution/configured_proxy_resolution_service.cc
+++ b/net/proxy_resolution/configured_proxy_resolution_service.cc
@@ -1405,6 +1405,20 @@ bool ConfiguredProxyResolutionService::CastToConfiguredProxyResolutionService(
   return true;
 }
 
+std::unique_ptr<ProxyConfigService>
+ConfiguredProxyResolutionService::CreateFixedSystemProxyConfigService(
+    const scoped_refptr<base::SequencedTaskRunner>& main_task_runner, base::StringPiece uri) {
+  ProxyConfig raw_proxy_config;
+  raw_proxy_config.proxy_rules().type = ProxyConfig::ProxyRules::Type::PROXY_LIST;
+  raw_proxy_config.proxy_rules().single_proxies.SetSingleProxyServer(ProxyUriToProxyServer(uri, ProxyServer::SCHEME_SOCKS5));
+#if (!defined(OS_WIN) && !defined(OS_LINUX)) || defined(OS_CHROMEOS)
+  ProxyConfigWithAnnotation proxy_config = ProxyConfigWithAnnotation(raw_proxy_config, NO_TRAFFIC_ANNOTATION_YET);
+#else
+  ProxyConfigWithAnnotation proxy_config = ProxyConfigWithAnnotation(raw_proxy_config, kSystemProxyConfigTrafficAnnotation);
+#endif
+  return std::make_unique<ProxyConfigServiceFixed>(proxy_config);
+}
+
 // static
 std::unique_ptr<ProxyConfigService>
 ConfiguredProxyResolutionService::CreateSystemProxyConfigService(
diff --git a/net/proxy_resolution/configured_proxy_resolution_service.h b/net/proxy_resolution/configured_proxy_resolution_service.h
index 80b96262c640d..b5b985f911cca 100644
--- a/net/proxy_resolution/configured_proxy_resolution_service.h
+++ b/net/proxy_resolution/configured_proxy_resolution_service.h
@@ -227,6 +227,9 @@ class NET_EXPORT ConfiguredProxyResolutionService
       const std::string& pac_string,
       const NetworkTrafficAnnotationTag& traffic_annotation);
 
+  static std::unique_ptr<ProxyConfigService> CreateFixedSystemProxyConfigService(
+      const scoped_refptr<base::SequencedTaskRunner>& main_task_runner, base::StringPiece uri);
+
   // Creates a config service appropriate for this platform that fetches the
   // system proxy settings. |main_task_runner| is the thread where the consumer
   // of the ProxyConfigService will live.
diff --git a/net/socket/client_socket_pool_manager.cc b/net/socket/client_socket_pool_manager.cc
index b41e79eb1bfb6..f2172712c984c 100644
--- a/net/socket/client_socket_pool_manager.cc
+++ b/net/socket/client_socket_pool_manager.cc
@@ -48,7 +48,7 @@ static_assert(std::size(g_max_sockets_per_pool) ==
 // be the same as the limit for ws. Also note that Firefox uses a limit of 200.
 // See http://crbug.com/486800
 int g_max_sockets_per_group[] = {
-    6,   // NORMAL_SOCKET_POOL
+    60,  // NORMAL_SOCKET_POOL
     255  // WEBSOCKET_SOCKET_POOL
 };
 
diff --git a/net/spdy/spdy_http_utils.cc b/net/spdy/spdy_http_utils.cc
index 80ca0386e6328..7a299fa0ed2e9 100644
--- a/net/spdy/spdy_http_utils.cc
+++ b/net/spdy/spdy_http_utils.cc
@@ -111,6 +111,11 @@ void CreateSpdyHeadersFromHttpRequest(const HttpRequestInfo& info,
   HttpRequestHeaders::Iterator it(request_headers);
   while (it.GetNext()) {
     std::string name = base::ToLowerASCII(it.name());
+    if (!name.empty() && name == "host") {
+        (*headers)[spdy::kHttp2AuthorityHeader] = it.value();
+       continue;
+    }
+
     if (name.empty() || name[0] == ':' || name == "connection" ||
         name == "proxy-connection" || name == "transfer-encoding" ||
         name == "host") {
diff --git a/net/ssl/ssl_config_service_defaults.cc b/net/ssl/ssl_config_service_defaults.cc
index 9348bb1648927..5fa9090f85cb1 100644
--- a/net/ssl/ssl_config_service_defaults.cc
+++ b/net/ssl/ssl_config_service_defaults.cc
@@ -9,6 +9,10 @@ namespace net {
 SSLConfigServiceDefaults::SSLConfigServiceDefaults() = default;
 SSLConfigServiceDefaults::~SSLConfigServiceDefaults() = default;
 
+SSLConfigServiceDefaults::SSLConfigServiceDefaults(SSLContextConfig default_config): default_config_(default_config) {
+  // default_config.disabled_cipher_suites = default_config_.disabled_cipher_suites;
+}
+
 SSLContextConfig SSLConfigServiceDefaults::GetSSLContextConfig() {
   return default_config_;
 }
diff --git a/net/ssl/ssl_config_service_defaults.h b/net/ssl/ssl_config_service_defaults.h
index c77a29140df77..5289c938b09c7 100644
--- a/net/ssl/ssl_config_service_defaults.h
+++ b/net/ssl/ssl_config_service_defaults.h
@@ -21,6 +21,7 @@ class NET_EXPORT SSLConfigServiceDefaults : public SSLConfigService {
   SSLConfigServiceDefaults& operator=(const SSLConfigServiceDefaults&) = delete;
 
   ~SSLConfigServiceDefaults() override;
+  SSLConfigServiceDefaults(SSLContextConfig default_config);
 
   // Returns the default SSL config settings.
   SSLContextConfig GetSSLContextConfig() override;
diff --git a/net/url_request/url_request_context.cc b/net/url_request/url_request_context.cc
index 49a42847aa25e..ced2844f5cdfa 100644
--- a/net/url_request/url_request_context.cc
+++ b/net/url_request/url_request_context.cc
@@ -101,6 +101,11 @@ std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
 }
 #endif
 
+// [breakerspace]
+void URLRequestContext::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
     const GURL& url,
     RequestPriority priority,
@@ -108,6 +113,11 @@ std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
     NetworkTrafficAnnotationTag traffic_annotation,
     bool is_for_websockets,
     const absl::optional<net::NetLogSource> net_log_source) const {
+  VLOG(1) << "[breakerspace] URLRequestContext::CreateRequest()";
+  
+  // [breakerspace]	
+  host_resolver()->SetStrategyInManager(strategy);
+ 
   return base::WrapUnique(new URLRequest(url, priority, delegate, this,
                                          traffic_annotation, is_for_websockets,
                                          net_log_source));
diff --git a/net/url_request/url_request_context.h b/net/url_request/url_request_context.h
index 27df35f3e4832..85886680a03fc 100644
--- a/net/url_request/url_request_context.h
+++ b/net/url_request/url_request_context.h
@@ -102,6 +102,9 @@ class NET_EXPORT URLRequestContext {
       URLRequest::Delegate* delegate) const;
 #endif
 
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+  
   // `traffic_annotation` is metadata about the network traffic send via this
   // URLRequest, see net::DefineNetworkTrafficAnnotation. Note that:
   // - net provides the API for tagging requests with an opaque identifier.
@@ -233,6 +236,9 @@ class NET_EXPORT URLRequestContext {
     return bound_network_;
   }
 
+  void set_envoy_url(const std::string& envoy_url) { envoy_url_ = envoy_url; }
+  const std::string& envoy_url() const { return envoy_url_; }
+
   void AssertCalledOnValidThread() {
     DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   }
@@ -360,6 +366,10 @@ class NET_EXPORT URLRequestContext {
   // Triggers a DCHECK if a NetworkIsolationKey/IsolationInfo is not provided to
   // a request when true.
   bool require_network_isolation_key_;
+  std::string envoy_url_;
+
+  // [breakerspace]
+  unsigned int strategy = 0;
 
   NetworkChangeNotifier::NetworkHandle bound_network_;
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index f3160569254a1..43bcee9811b6a 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -13,6 +13,7 @@
 #include "base/compiler_specific.h"
 #include "base/notreached.h"
 #include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/thread_pool.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -20,6 +21,7 @@
 #include "net/base/cache_type.h"
 #include "net/base/net_errors.h"
 #include "net/base/network_delegate_impl.h"
+#include "net/base/url_util.h"
 #include "net/cert/cert_verifier.h"
 #include "net/cert/ct_log_verifier.h"
 #include "net/cert/ct_policy_enforcer.h"
@@ -30,6 +32,7 @@
 #include "net/dns/context_host_resolver.h"
 #include "net/dns/host_resolver.h"
 #include "net/dns/host_resolver_manager.h"
+#include "net/dns/mapped_host_resolver.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_network_layer.h"
@@ -45,6 +48,7 @@
 #include "net/quic/quic_context.h"
 #include "net/quic/quic_stream_factory.h"
 #include "net/socket/network_binding_client_socket_factory.h"
+#include "net/ssl/ssl_cipher_suite_names.h"
 #include "net/ssl/ssl_config_service_defaults.h"
 #include "net/url_request/static_http_user_agent_settings.h"
 #include "net/url_request/url_request_context.h"
@@ -185,6 +189,10 @@ void URLRequestContextBuilder::set_user_agent(const std::string& user_agent) {
   user_agent_ = user_agent;
 }
 
+void URLRequestContextBuilder::set_envoy_url(const std::string& envoy_url) {
+  envoy_url_ = envoy_url;
+}
+
 void URLRequestContextBuilder::set_http_user_agent_settings(
     std::unique_ptr<HttpUserAgentSettings> http_user_agent_settings) {
   http_user_agent_settings_ = std::move(http_user_agent_settings);
@@ -337,6 +345,8 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   context->set_require_network_isolation_key(require_network_isolation_key_);
   context->set_network_quality_estimator(network_quality_estimator_);
 
+  if (!envoy_url_.empty())
+    context->set_envoy_url(envoy_url_);
   if (http_user_agent_settings_) {
     storage->set_http_user_agent_settings(std::move(http_user_agent_settings_));
   } else {
@@ -418,13 +428,53 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
     }
   }
   host_resolver_->SetRequestContext(context.get());
-  storage->set_host_resolver(std::move(host_resolver_));
+
+  auto envoy_url = GURL(envoy_url_);
+  std::string value;
+  GetValueForKeyInQuery(envoy_url, "url", &value);
+  // TODO assert value
+  auto url = GURL(value);
+
+  if (GetValueForKeyInQuery(envoy_url, "resolve", &value)) {
+    std::unique_ptr<net::MappedHostResolver> remapped_resolver(
+        new net::MappedHostResolver(std::move(host_resolver_)));
+    remapped_resolver->SetRulesFromString(value);
+    storage->set_host_resolver(std::move(remapped_resolver));
+  } else if (GetValueForKeyInQuery(envoy_url, "address", &value)) {
+    std::unique_ptr<net::MappedHostResolver> remapped_resolver(
+        new net::MappedHostResolver(std::move(host_resolver_)));
+    remapped_resolver->SetRulesFromString("MAP " + url.host() + " " + value);
+    storage->set_host_resolver(std::move(remapped_resolver));
+  } else {
+    storage->set_host_resolver(std::move(host_resolver_));
+  }
 
   if (ssl_config_service_) {
     storage->set_ssl_config_service(std::move(ssl_config_service_));
   } else {
-    storage->set_ssl_config_service(
-        std::make_unique<SSLConfigServiceDefaults>());
+
+    SSLContextConfig ssl_context_config;
+    std::vector<uint16_t> disabled_ciphers;
+    if (GetValueForKeyInQuery(envoy_url, "disabled_cipher_suites", &value)) {
+      auto cipher_strings = base::SplitString(value, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
+      // see net::ParseCipherSuites(cipher_strings);
+      std::vector<uint16_t> cipher_suites;
+      cipher_suites.reserve(cipher_strings.size());
+
+      for (auto it = cipher_strings.begin(); it != cipher_strings.end(); ++it) {
+        uint16_t cipher_suite = 0;
+        if (!net::ParseSSLCipherString(*it, &cipher_suite)) {
+          LOG(ERROR) << "Ignoring unrecognized or unparsable cipher suite: " << *it;
+          continue;
+        }
+        cipher_suites.push_back(cipher_suite);
+      }
+      std::sort(cipher_suites.begin(), cipher_suites.end());
+
+      ssl_context_config.disabled_cipher_suites =  cipher_suites;
+    }
+    auto ssl_config_service_ptr = std::make_unique<SSLConfigServiceDefaults>(ssl_context_config);
+    storage->set_ssl_config_service(std::move(ssl_config_service_ptr));
   }
 
   if (http_auth_handler_factory_) {
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index 7bdf93aeb7aa1..0ad42c07c1301 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -188,6 +188,7 @@ class NET_EXPORT URLRequestContextBuilder {
   // have the headers already set.
   void set_accept_language(const std::string& accept_language);
   void set_user_agent(const std::string& user_agent);
+  void set_envoy_url(const std::string& envoy_url);
 
   // Makes the created URLRequestContext use a particular HttpUserAgentSettings
   // object. Not compatible with set_accept_language() / set_user_agent().
@@ -395,6 +396,7 @@ class NET_EXPORT URLRequestContextBuilder {
 
   std::string accept_language_;
   std::string user_agent_;
+  std::string envoy_url_;
   std::unique_ptr<HttpUserAgentSettings> http_user_agent_settings_;
 
   bool http_cache_enabled_ = true;
diff --git a/net/url_request/url_request_http_job.cc b/net/url_request/url_request_http_job.cc
index 2db8e1bc9e5bb..f658e2c06f83e 100644
--- a/net/url_request/url_request_http_job.cc
+++ b/net/url_request/url_request_http_job.cc
@@ -18,6 +18,7 @@
 #include "base/compiler_specific.h"
 #include "base/containers/adapters.h"
 #include "base/file_version_info.h"
+#include "crypto/sha2.h"
 #include "base/location.h"
 #include "base/memory/ptr_util.h"
 #include "base/metrics/field_trial.h"
@@ -34,6 +35,7 @@
 #include "base/trace_event/trace_event.h"
 #include "base/values.h"
 #include "build/build_config.h"
+#include "net/base/escape.h"
 #include "net/base/features.h"
 #include "net/base/host_port_pair.h"
 #include "net/base/http_user_agent_settings.h"
@@ -558,6 +560,46 @@ void URLRequestHttpJob::StartTransactionInternal() {
 
       if (!throttling_entry_.get() ||
           !throttling_entry_->ShouldRejectRequest(*request_)) {
+        if (request_->context()->envoy_url().rfind("http://", 0) == 0 ||
+            request_->context()->envoy_url().rfind("https://", 0) == 0) {
+          // https://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID
+          // default to random value, no cache at all
+          auto salt = base::RandBytesAsString(16);
+          auto envoy_url = GURL(request_->context()->envoy_url());
+          if (envoy_url.SchemeIsHTTPOrHTTPS()) {
+            request_info_.url = envoy_url; // TODO check is_vaid() before set
+          } else if (envoy_url.scheme().compare("envoy") == 0) {
+            std::string headerPrefix = "header_";
+            auto headerPrefixLength = headerPrefix.size();
+
+            for (QueryIterator it(envoy_url); !it.IsAtEnd(); it.Advance()) {
+              auto key = it.GetKey();
+              auto value = it.GetUnescapedValue();
+              if (key.compare("url") == 0) {
+                // see GetUnescapedValue, TODO check is_valid() before set
+                request_info_.url =
+                    GURL(net::UnescapeURLComponent(value, UnescapeRule::NORMAL));
+             } else if (key.compare("salt") == 0) {
+                     salt = value;
+              } else if (key.rfind(headerPrefix, 0) == 0 &&
+                         key.size() > headerPrefixLength) {
+                request_info_.extra_headers.SetHeader(
+                    key.substr(headerPrefixLength), value); // check for header Host, add :authority for http2; :path for http2
+              }
+            }
+          }
+
+          // count for cache key
+          auto digest = crypto::SHA256HashString(request_->url().spec() + salt);
+          request_info_.url =
+              AppendQueryParameter(request_info_.url, "_digest", digest);
+          // TODO encode field value
+          request_info_.extra_headers.SetHeader("Url-Orig",
+                                                request_->url().spec());
+          request_info_.extra_headers.SetHeader("Host-Orig",
+                                                request_->url().host());
+        }
+
         rv = transaction_->Start(
             &request_info_,
             base::BindOnce(&URLRequestHttpJob::OnStartCompleted,
diff --git a/third_party/shadowsocks/BUILD.gn b/third_party/shadowsocks/BUILD.gn
new file mode 100644
index 0000000000000..bd33744461f0d
--- /dev/null
+++ b/third_party/shadowsocks/BUILD.gn
@@ -0,0 +1,6 @@
+import("//build/config/android/abi.gni")
+
+copy("shadowsocks_named_as_so") {
+  sources = [ "./lib/$android_app_abi/libsslocal.so" ]
+  outputs = [ "$root_out_dir/libsslocal.so" ]
+}
