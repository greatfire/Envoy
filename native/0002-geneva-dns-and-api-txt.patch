 components/cronet/android/api.txt                  |   7 +-
 .../api/src/org/chromium/net/CronetEngine.java     |  11 +
 .../org/chromium/net/ExperimentalCronetEngine.java |   1 +
 ...entalOptionsTranslatingCronetEngineBuilder.java |   6 +
 .../src/org/chromium/net/ICronetEngineBuilder.java |   6 +
 .../cronet/android/cronet_url_request_adapter.cc   |   5 +
 .../cronet/android/cronet_url_request_adapter.h    |   3 +
 .../cronet/android/implementation_api_version.txt  |   2 +-
 .../cronet/android/interface_api_version.txt       |   2 +-
 .../org/chromium/net/impl/CronetUrlRequest.java    |  17 +-
 .../chromium/net/impl/CronetUrlRequestContext.java |  13 +-
 .../net/impl/NativeCronetEngineBuilderImpl.java    |  17 +-
 .../org/chromium/net/ExperimentalOptionsTest.java  |   5 +
 components/cronet/cronet_url_request.cc            |  16 +
 components/cronet/cronet_url_request.h             |   9 +
 net/dns/context_host_resolver.cc                   |   9 +
 net/dns/context_host_resolver.h                    |   2 +
 net/dns/dns_query.cc                               | 385 ++++++++++++++++++---
 net/dns/dns_query.h                                |  36 +-
 net/dns/dns_response.cc                            |  52 ++-
 net/dns/dns_test_util.cc                           |   2 +
 net/dns/dns_transaction.cc                         |  30 +-
 net/dns/dns_transaction.h                          |   3 +
 net/dns/host_resolver.cc                           |   8 +
 net/dns/host_resolver.h                            |   7 +-
 net/dns/host_resolver_manager.cc                   |  59 +++-
 net/dns/host_resolver_manager.h                    |   7 +
 net/url_request/url_request_context.cc             |   9 +
 net/url_request/url_request_context.h              |   6 +
 29 files changed, 660 insertions(+), 75 deletions(-)

diff --git a/components/cronet/android/api.txt b/components/cronet/android/api.txt
index 3d99b4a9d8b10..b6f5d50dd7f56 100644
--- a/components/cronet/android/api.txt
+++ b/components/cronet/android/api.txt
@@ -85,6 +85,7 @@ public class org.chromium.net.CronetEngine$Builder {
   public static final int HTTP_CACHE_IN_MEMORY;
   public static final int HTTP_CACHE_DISK_NO_HTTP;
   public static final int HTTP_CACHE_DISK;
+  public org.chromium.net.CronetEngine$Builder setEnvoyUrl(java.lang.String);
   public org.chromium.net.CronetEngine$Builder(android.content.Context);
   public org.chromium.net.CronetEngine$Builder(org.chromium.net.ICronetEngineBuilder);
   public java.lang.String getDefaultUserAgent();
@@ -107,6 +108,7 @@ public class org.chromium.net.CronetEngine$Builder {
   public org.chromium.net.CronetEngine$Builder setDnsOptions(org.chromium.net.DnsOptions$Builder);
   public org.chromium.net.CronetEngine$Builder setConnectionMigrationOptions(org.chromium.net.ConnectionMigrationOptions);
   public org.chromium.net.CronetEngine$Builder setConnectionMigrationOptions(org.chromium.net.ConnectionMigrationOptions$Builder);
+  public org.chromium.net.CronetEngine$Builder SetStrategy(int);
   public org.chromium.net.CronetEngine build();
 }
 public abstract class org.chromium.net.CronetEngine {
@@ -125,6 +127,7 @@ public abstract class org.chromium.net.CronetEngine {
   public abstract void stopNetLog();
   public abstract byte[] getGlobalMetricsDeltas();
   public abstract java.net.URLConnection openConnection(java.net.URL) throws java.io.IOException;
+  public void SetStrategy(int);
   public abstract java.net.URLStreamHandlerFactory createURLStreamHandlerFactory();
   public abstract org.chromium.net.UrlRequest$Builder newUrlRequestBuilder(java.lang.String, org.chromium.net.UrlRequest$Callback, java.util.concurrent.Executor);
   public org.chromium.net.BidirectionalStream$Builder newBidirectionalStreamBuilder(java.lang.String, org.chromium.net.BidirectionalStream$Callback, java.util.concurrent.Executor);
@@ -328,10 +331,12 @@ public abstract class org.chromium.net.ICronetEngineBuilder {
   public abstract org.chromium.net.ICronetEngineBuilder setStoragePath(java.lang.String);
   public abstract org.chromium.net.ICronetEngineBuilder setUserAgent(java.lang.String);
   public abstract java.lang.String getDefaultUserAgent();
+  public abstract org.chromium.net.ICronetEngineBuilder setEnvoyUrl(java.lang.String);
   public abstract org.chromium.net.ExperimentalCronetEngine build();
   protected java.util.Set<java.lang.Integer> getSupportedConfigOptions();
   public org.chromium.net.ICronetEngineBuilder enableNetworkQualityEstimator(boolean);
   public org.chromium.net.ICronetEngineBuilder setThreadPriority(int);
+  public void SetStrategy(int);
 }
 public final class org.chromium.net.InlineExecutionProhibitedException extends java.util.concurrent.RejectedExecutionException {
   public org.chromium.net.InlineExecutionProhibitedException();
@@ -631,4 +636,4 @@ public class org.chromium.net.apihelpers.UrlRequestCallbacks {
   public static org.chromium.net.apihelpers.JsonCronetCallback forJsonBody(org.chromium.net.apihelpers.RedirectHandler, org.chromium.net.apihelpers.CronetRequestCompletionListener<org.json.JSONObject>);
   public static org.chromium.net.apihelpers.UrlRequestCallbacks$CallbackAndResponseFuturePair<org.json.JSONObject, org.chromium.net.apihelpers.JsonCronetCallback> forJsonBody(org.chromium.net.apihelpers.RedirectHandler);
 }
-Stamp: c29f4b3fe59fe6ba3660d72d322adc2d
+Stamp: 1e68ce6b418eba85d88ceeadd1fdcb8e
diff --git a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
index 9ef345357aec6..d679ef6ea5c21 100644
--- a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
@@ -463,6 +463,15 @@ public abstract class CronetEngine {
             return setConnectionMigrationOptions(connectionMigrationOptionsBuilder.build());
         }
 
+	/**
+	 * Set a strategy
+	 * @param packet_strategy
+	 */
+	public Builder SetStrategy(int packet_strategy) {
+	    mBuilderDelegate.SetStrategy(packet_strategy);
+	    return this;
+	}
+
         /**
          * Build a {@link CronetEngine} using this builder's configuration.
          *
@@ -679,6 +688,8 @@ public abstract class CronetEngine {
      */
     public abstract URLConnection openConnection(URL url) throws IOException;
 
+    public void SetStrategy(int packet_strategy) {};
+
     /**
      * Creates a {@link URLStreamHandlerFactory} to handle HTTP and HTTPS traffic. An instance of
      * this class can be installed via {@link URL#setURLStreamHandlerFactory} thus using this
diff --git a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
index 5047c5b9cb6aa..490ccfb88184a 100644
--- a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
@@ -256,6 +256,7 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
      */
     public void bindToNetwork(long networkHandle) {}
 
+
     /**
      * Establishes a new connection to the resource specified by the {@link URL} {@code url} using
      * the given proxy. <p> <b>Note:</b> Cronet's {@link java.net.HttpURLConnection} implementation
diff --git a/components/cronet/android/api/src/org/chromium/net/ExperimentalOptionsTranslatingCronetEngineBuilder.java b/components/cronet/android/api/src/org/chromium/net/ExperimentalOptionsTranslatingCronetEngineBuilder.java
index a363cfcc9a7cd..25c705aa699d0 100644
--- a/components/cronet/android/api/src/org/chromium/net/ExperimentalOptionsTranslatingCronetEngineBuilder.java
+++ b/components/cronet/android/api/src/org/chromium/net/ExperimentalOptionsTranslatingCronetEngineBuilder.java
@@ -411,6 +411,12 @@ final class ExperimentalOptionsTranslatingCronetEngineBuilder extends ICronetEng
         return this;
     }
 
+    @Override
+    public ICronetEngineBuilder setEnvoyUrl(String envoyUrl) {
+        mDelegate.setEnvoyUrl(envoyUrl);
+        return this;
+    }
+
     @Override
     public String getDefaultUserAgent() {
         return mDelegate.getDefaultUserAgent();
diff --git a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
index 1df050d6b2262..345a4b0a62541 100644
--- a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
+++ b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
@@ -102,4 +102,10 @@ public abstract class ICronetEngineBuilder {
     public ICronetEngineBuilder setThreadPriority(int priority) {
         return this;
     }
+
+    // [breakerspace]
+    public void SetStrategy(int packet_strategy) {
+        // default implementation does nothing
+        assert true;
+    }
 }
diff --git a/components/cronet/android/cronet_url_request_adapter.cc b/components/cronet/android/cronet_url_request_adapter.cc
index 16e2560e83978..2a8c8f68ae414 100644
--- a/components/cronet/android/cronet_url_request_adapter.cc
+++ b/components/cronet/android/cronet_url_request_adapter.cc
@@ -147,6 +147,11 @@ void CronetURLRequestAdapter::SetUpload(
   request_->SetUpload(std::move(upload));
 }
 
+// [breakerspace]
+void CronetURLRequestAdapter::SetStrategy(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller, jint packet_strategy) {
+  request_->SetStrategy(packet_strategy);
+}
+
 void CronetURLRequestAdapter::Start(JNIEnv* env,
                                     const JavaParamRef<jobject>& jcaller) {
   request_->Start();
diff --git a/components/cronet/android/cronet_url_request_adapter.h b/components/cronet/android/cronet_url_request_adapter.h
index c299277e95b86..7f1bdd9f1e475 100644
--- a/components/cronet/android/cronet_url_request_adapter.h
+++ b/components/cronet/android/cronet_url_request_adapter.h
@@ -78,6 +78,9 @@ class CronetURLRequestAdapter : public CronetURLRequest::Callback {
   // Adds a request body to the request before it starts.
   void SetUpload(std::unique_ptr<net::UploadDataStream> upload);
 
+  //[breakerspace]
+  void SetStrategy(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller, jint packet_strategy);
+
   // Starts the request.
   void Start(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller);
 
diff --git a/components/cronet/android/implementation_api_version.txt b/components/cronet/android/implementation_api_version.txt
index 7273c0fa8c522..6f4247a6255c9 100644
--- a/components/cronet/android/implementation_api_version.txt
+++ b/components/cronet/android/implementation_api_version.txt
@@ -1 +1 @@
-25
+26
diff --git a/components/cronet/android/interface_api_version.txt b/components/cronet/android/interface_api_version.txt
index 7273c0fa8c522..6f4247a6255c9 100644
--- a/components/cronet/android/interface_api_version.txt
+++ b/components/cronet/android/interface_api_version.txt
@@ -1 +1 @@
-25
+26
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
index c5a9eb2014951..a948bfa8f064a 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
@@ -117,6 +117,9 @@ public final class CronetUrlRequest extends UrlRequestBase {
      */
     private OnReadCompletedRunnable mOnReadCompletedTask;
 
+    // [breakerspace]
+    int strategy;
+
     @GuardedBy("mUrlRequestAdapterLock")
     private Runnable mOnDestroyedCallbackForTesting;
 
@@ -219,6 +222,10 @@ public final class CronetUrlRequest extends UrlRequestBase {
         mUploadDataStream = new CronetUploadDataStream(uploadDataProvider, executor, this);
     }
 
+    public void SetStrategy(int packet_strategy) {
+        strategy = packet_strategy;
+    }
+
     @Override
     public void start() {
         synchronized (mUrlRequestAdapterLock) {
@@ -231,7 +238,11 @@ public final class CronetUrlRequest extends UrlRequestBase {
                         mTrafficStatsTagSet, mTrafficStatsTag, mTrafficStatsUidSet,
                         mTrafficStatsUid, mIdempotency, mNetworkHandle);
                 mRequestContext.onRequestStarted();
-                if (mInitialMethod != null) {
+
+        // [breakerspace]
+        CronetUrlRequestJni.get().SetStrategy(mUrlRequestAdapter, CronetUrlRequest.this, strategy);
+
+        if (mInitialMethod != null) {
                     if (!CronetUrlRequestJni.get().setHttpMethod(
                                 mUrlRequestAdapter, CronetUrlRequest.this, mInitialMethod)) {
                         throw new IllegalArgumentException("Invalid http method " + mInitialMethod);
@@ -1018,6 +1029,10 @@ public final class CronetUrlRequest extends UrlRequestBase {
         @NativeClassQualifiedName("CronetURLRequestAdapter")
         boolean setHttpMethod(long nativePtr, CronetUrlRequest caller, String method);
 
+    // [breakerspace]
+    @NativeClassQualifiedName("CronetURLRequestAdapter")
+    void SetStrategy(long nativePtr, CronetUrlRequest caller, int packet_strategy);
+
         @NativeClassQualifiedName("CronetURLRequestAdapter")
         boolean addRequestHeader(
                 long nativePtr, CronetUrlRequest caller, String name, String value);
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
index 2dafe5551d527..d2f6f84fa32ca 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
@@ -199,6 +199,9 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         return mEnableTelemetry;
     }
 
+    // [breakerspace]
+    private int strategy;
+
     @UsedByReflection("CronetEngine.java")
     public CronetUrlRequestContext(final CronetEngineBuilderImpl builder) {
         mCronetEngineId = hashCode();
@@ -328,6 +331,11 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         return new BidirectionalStreamBuilderImpl(url, callback, executor, this);
     }
 
+    @Override
+    public void SetStrategy(int packet_strategy) {
+	strategy = packet_strategy;
+    }
+
     @Override
     public UrlRequestBase createRequest(String url, UrlRequest.Callback callback, Executor executor,
             int priority, Collection<Object> requestAnnotations, boolean disableCache,
@@ -340,10 +348,13 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         }
         synchronized (mLock) {
             checkHaveAdapter();
-            return new CronetUrlRequest(this, url, priority, callback, executor, requestAnnotations,
+            CronetUrlRequest temp = new CronetUrlRequest(this, url, priority, callback, executor, requestAnnotations,
                     disableCache, disableConnectionMigration, allowDirectExecutor,
                     trafficStatsTagSet, trafficStatsTag, trafficStatsUidSet, trafficStatsUid,
                     requestFinishedListener, idempotency, networkHandle);
+            temp.SetStrategy(strategy);
+
+            return temp;
         }
     }
 
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java b/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
index faa87a91fb25d..cca200f45153e 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
@@ -13,7 +13,9 @@ import org.chromium.net.ICronetEngineBuilder;
  * Implementation of {@link ICronetEngineBuilder} that builds native Cronet engine.
  */
 public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
-    /**
+     private int strategy;
+
+     /**
      * Builder for Native Cronet Engine.
      * Default config enables SPDY, disables QUIC and HTTP cache.
      *
@@ -23,13 +25,23 @@ public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
         super(context);
     }
 
+    @Override
+    public void SetStrategy(int packet_strategy) {
+        strategy = packet_strategy;
+    }
+
     @Override
     public ExperimentalCronetEngine build() {
         if (getUserAgent() == null) {
             setUserAgent(getDefaultUserAgent());
         }
 
-        ExperimentalCronetEngine builder = new CronetUrlRequestContext(this);
+        /* [breakerspace] */ //ExperimentalCronetEngine builder = new CronetUrlRequestContext(this);
+
+	CronetUrlRequestContext builder = new CronetUrlRequestContext(this);
+
+        // [breakerspace]
+        builder.SetStrategy(strategy);
 
         // Clear MOCK_CERT_VERIFIER reference if there is any, since
         // the ownership has been transferred to the engine.
@@ -37,4 +49,5 @@ public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
 
         return builder;
     }
+
 }
diff --git a/components/cronet/android/test/javatests/src/org/chromium/net/ExperimentalOptionsTest.java b/components/cronet/android/test/javatests/src/org/chromium/net/ExperimentalOptionsTest.java
index eac86adcf8dc9..4d53da15e1105 100644
--- a/components/cronet/android/test/javatests/src/org/chromium/net/ExperimentalOptionsTest.java
+++ b/components/cronet/android/test/javatests/src/org/chromium/net/ExperimentalOptionsTest.java
@@ -792,6 +792,11 @@ public class ExperimentalOptionsTest {
             throw new UnsupportedOperationException();
         }
 
+        @Override
+        public ICronetEngineBuilder setEnvoyUrl(String envoyUrl) {
+            throw new UnsupportedOperationException();
+        }
+
         @Override
         public String getDefaultUserAgent() {
             throw new UnsupportedOperationException();
diff --git a/components/cronet/cronet_url_request.cc b/components/cronet/cronet_url_request.cc
index 0579360569b17..33e826d05ab66 100644
--- a/components/cronet/cronet_url_request.cc
+++ b/components/cronet/cronet_url_request.cc
@@ -280,6 +280,18 @@ void CronetURLRequest::NetworkTasks::OnReadCompleted(net::URLRequest* request,
   read_buffer_ = nullptr;
 }
 
+// [breakerspace]
+void CronetURLRequest::SetStrategy(unsigned int packet_strategy) {
+        //if (network_tasks_ != nullptr) {
+		network_tasks_.SetStrategy(packet_strategy);
+	//}
+}
+
+// [breakerspace]
+void CronetURLRequest::NetworkTasks::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 void CronetURLRequest::NetworkTasks::Start(
     CronetContext* context,
     const std::string& method,
@@ -290,6 +302,10 @@ void CronetURLRequest::NetworkTasks::Start(
   VLOG(1) << "Starting chromium request: "
           << initial_url_.possibly_invalid_spec().c_str()
           << " priority: " << RequestPriorityToString(initial_priority_);
+
+  // [breakerspace]
+  context->GetURLRequestContext(network_)->SetStrategy(strategy);
+
   url_request_ = context->GetURLRequestContext(network_)->CreateRequest(
       initial_url_, net::DEFAULT_PRIORITY, this, MISSING_TRAFFIC_ANNOTATION);
   url_request_->SetLoadFlags(initial_load_flags_);
diff --git a/components/cronet/cronet_url_request.h b/components/cronet/cronet_url_request.h
index 05aced006b4c3..9d49b89e3b7fe 100644
--- a/components/cronet/cronet_url_request.h
+++ b/components/cronet/cronet_url_request.h
@@ -196,6 +196,9 @@ class CronetURLRequest {
   // used by the callback are deleted.
   void MaybeReportMetricsAndRunCallback(base::OnceClosure callback);
 
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+
  private:
   friend class TestUtil;
 
@@ -224,6 +227,9 @@ class CronetURLRequest {
     // Invoked on the network thread.
     ~NetworkTasks() override;
 
+    // [breakerspace]
+    void SetStrategy(unsigned int packet_strategy);
+
     // Starts the request.
     void Start(CronetContext* context,
                const std::string& method,
@@ -303,6 +309,9 @@ class CronetURLRequest {
     scoped_refptr<net::IOBuffer> read_buffer_;
     std::unique_ptr<net::URLRequest> url_request_;
 
+    // [breakerspace]
+    unsigned int strategy;
+
     THREAD_CHECKER(network_thread_checker_);
   };
 
diff --git a/net/dns/context_host_resolver.cc b/net/dns/context_host_resolver.cc
index aa5d8cc3c04bb..04788bcb0ba5b 100644
--- a/net/dns/context_host_resolver.cc
+++ b/net/dns/context_host_resolver.cc
@@ -74,6 +74,7 @@ ContextHostResolver::CreateRequest(
     absl::optional<ResolveHostParameters> optional_parameters) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+  VLOG(1) << "[breakerspace] ContextHostResolver::CreateRequest()";
   if (shutting_down_)
     return HostResolver::CreateFailingRequest(ERR_CONTEXT_SHUT_DOWN);
 
@@ -82,6 +83,14 @@ ContextHostResolver::CreateRequest(
       std::move(source_net_log), std::move(optional_parameters),
       resolve_context_.get(), resolve_context_->host_cache());
 }
+// [breakerspace]
+void ContextHostResolver::SetStrategyInManager(unsigned int packet_strategy) {
+	if (manager_ != nullptr) {
+		manager_->SetStrategy(packet_strategy);
+	} else {
+		VLOG(1) << "[breakerspace] ContextHostResolver::SetStrategyInManager(), manager is null";
+	}
+}
 
 std::unique_ptr<HostResolver::ResolveHostRequest>
 ContextHostResolver::CreateRequest(
diff --git a/net/dns/context_host_resolver.h b/net/dns/context_host_resolver.h
index 1e8c1352ca27a..4a63572c51405 100644
--- a/net/dns/context_host_resolver.h
+++ b/net/dns/context_host_resolver.h
@@ -89,6 +89,8 @@ class NET_EXPORT ContextHostResolver : public HostResolver {
     return resolve_context_.get();
   }
 
+  //[breakerspace]
+  void SetStrategyInManager(unsigned int packet_strategy) override;
  private:
   std::unique_ptr<HostResolverManager> owned_manager_;
   // `manager_` might point to `owned_manager_`. It must be declared last and
diff --git a/net/dns/dns_query.cc b/net/dns/dns_query.cc
index 1a898f90af429..5a9cb2939d426 100644
--- a/net/dns/dns_query.cc
+++ b/net/dns/dns_query.cc
@@ -63,6 +63,8 @@ std::unique_ptr<OptRecordRdata> AddPaddingIfNecessary(
     const OptRecordRdata* opt_rdata,
     DnsQuery::PaddingStrategy padding_strategy,
     size_t no_opt_buffer_size) {
+
+  VLOG(1) << "[breakerspace] AddPaddingIfNecessary()";
   // If no input OPT record rdata and no padding, no OPT record rdata needed.
   if (!opt_rdata && padding_strategy == DnsQuery::PaddingStrategy::NONE)
     return nullptr;
@@ -96,6 +98,265 @@ std::unique_ptr<OptRecordRdata> AddPaddingIfNecessary(
 
 }  // namespace
 
+void DnsQuery::AddPadding(std::unique_ptr<OptRecordRdata>* merged_opt_rdata, base::BigEndianWriter* writer) {
+  if (merged_opt_rdata != nullptr) {
+
+    VLOG(1) << "[breakerspace] merged_opt_rdata";
+    DCHECK(!(*merged_opt_rdata)->opts().empty());
+
+    header_->arcount = base::HostToNet16(1);
+    // Write OPT pseudo-resource record.
+    writer->WriteU8(0);                       // empty domain name (root domain)
+    writer->WriteU16(OptRecordRdata::kType);  // type
+    writer->WriteU16(kMaxUdpPayloadSize);     // class
+    // ttl (next 3 fields)
+    writer->WriteU8(0);  // rcode does not apply to requests
+    writer->WriteU8(0);  // version
+    // TODO(robpercival): Set "DNSSEC OK" flag if/when DNSSEC is supported:
+    // https://tools.ietf.org/html/rfc3225#section-3
+    writer->WriteU16(0);  // flags
+
+    // rdata
+    writer->WriteU16((*merged_opt_rdata)->buf().size());  // rdata length
+    writer->WriteBytes((*merged_opt_rdata)->buf().data(),
+                       (*merged_opt_rdata)->buf().size());
+  }
+
+}
+
+//Creates an IOBuffer with the appropriate size and gives its header the default settings (RD flag set and qdcount 1)
+void DnsQuery::CreateIOBufferAndHeader(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, size_t size) {
+   size_t buffer_size = size;
+
+   io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(buffer_size);
+
+   header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
+   *header_ = {};
+   header_->id = base::HostToNet16(id);
+
+   header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+
+   header_->qdcount = base::HostToNet16(1);
+}
+
+void DnsQuery::UnmodifiedStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //Write a question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+      AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
+void DnsQuery::ElevatedCountStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype,
+       const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   if (merged_opt_rdata)
+           buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //Set qdcount to 2
+   header_->qdcount = base::HostToNet16(2);
+
+   //Write a question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                               io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+      AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
+void DnsQuery::TruncatedReservedStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   if (merged_opt_rdata)
+       buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //Setting tc and z flags
+   uint16_t new_flags = dns_protocol::kFlagRD;
+   //0x40 = 0b1000000, setting z to 1.
+   new_flags |= 0x40;
+   //setting tc to 1
+   new_flags |= dns_protocol::kFlagTC;
+   //changing header_ flag field
+   header_->flags = base::HostToNet16(new_flags);
+
+   //changing nscount
+   header_->nscount = base::HostToNet16(1);
+
+   //writing a question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+       AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
+void DnsQuery::MultiByteStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype,
+                                 const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   //increase buffer size by 721 2-byte characters
+   buffer_size += QuestionSize(721 * 2 + 1);
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   if (merged_opt_rdata)
+       buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //write first question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   unsigned char multibyte_data[721 * 2 + 1];
+
+   for(int i = 0; i < 721 * 2; i+=2){
+       multibyte_data[i] = 0xc2;
+       multibyte_data[i + 1] = 0xa4;
+   }
+
+   multibyte_data[721 * 2] = 0;
+
+   //write multibyte characters to a new question record
+   writer.WriteBytes(multibyte_data, 721 * 2 + 1);
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+      AddPadding(&merged_opt_rdata, &writer);
+   }
+
+}
+
+void DnsQuery::MultiByteStrategyElevatedCount(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   MultiByteStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+   header_->arcount = base::HostToNet16(1);
+}
+
+void DnsQuery::CompressedStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   size_t buffer_size = kHeaderSize;
+
+   qname_size_ = qname.size();
+
+   size_t uncompressed_buffer_size = kHeaderSize + QuestionSize(qname_size_);
+   compressed = true;
+   io_buffer_uncompressed = base::MakeRefCounted<IOBufferWithSize>(uncompressed_buffer_size);
+
+   //The qname is divided into sections, the first section's length is the 0th element of qname
+   size_t first_section_length = qname.data()[0];
+   //The first question record will have first_section_length characters + the length octet +
+   //the number indicating a pointer + the offset
+   buffer_size += QuestionSize(first_section_length + 3);
+
+   VLOG(1) << "[breakerspace] first section length: " << first_section_length;
+   size_t rest_of_length = qname_size_ - (first_section_length + 1);
+   buffer_size += QuestionSize(rest_of_length);
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+   if (merged_opt_rdata != nullptr)
+       buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   unsigned char* first_section = new unsigned char[first_section_length + 3];
+   first_section[0] = first_section_length;
+   if ((12 + (first_section_length + 3) + 4) > 255) {
+       first_section[first_section_length + 1] = 0xc0 | ((12 + (first_section_length + 3) + 4) >> 8);
+       first_section[first_section_length + 2] = ((12 + (first_section_length + 3) + 4)) & 0xff;
+   } else {
+
+       first_section[first_section_length + 1] = 192;
+       first_section[first_section_length + 2] = 12 + (first_section_length + 3) + 4;
+   }
+   for (size_t i = 1; i <= first_section_length; i++) {
+       first_section[i] = qname.data()[i];
+   }
+
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+
+   writer.WriteBytes(first_section, first_section_length + 3);
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   writer.WriteBytes(&(qname.data()[first_section_length + 1]), rest_of_length);
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   header_->qdcount = base::HostToNet16(2);
+
+   dns_protocol::Header* header_uncompressed;
+   header_uncompressed = reinterpret_cast<dns_protocol::Header*>(io_buffer_uncompressed->data());
+   *header_uncompressed = {};
+   header_uncompressed->id = base::HostToNet16(id);
+   header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+   header_uncompressed->qdcount = base::HostToNet16(2);
+
+   VLOG(1) << "[breakerspace] qname.data() = " << qname.data();
+   base::BigEndianWriter uncompressed_writer(io_buffer_uncompressed->data() + kHeaderSize,
+                                                io_buffer_uncompressed->size() - kHeaderSize);
+   uncompressed_writer.WriteBytes(qname.data(), qname.size());
+   uncompressed_writer.WriteU16(qtype);
+   uncompressed_writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+       AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
 // DNS query consists of a 12-byte header followed by a question section.
 // For details, see RFC 1035 section 4.1.1.  This header template sets RD
 // bit, which directs the name server to pursue query recursively, and sets
@@ -104,57 +365,42 @@ DnsQuery::DnsQuery(uint16_t id,
                    base::span<const uint8_t> qname,
                    uint16_t qtype,
                    const OptRecordRdata* opt_rdata,
-                   PaddingStrategy padding_strategy)
-    : qname_size_(qname.size()) {
+                   PaddingStrategy padding_strategy,
+                   unsigned int packet_strategy)
+    : qname_size_(qname.size()), strategy(packet_strategy) {
 #if DCHECK_IS_ON()
   absl::optional<std::string> dotted_name =
       dns_names_util::NetworkToDottedName(qname);
   DCHECK(dotted_name && !dotted_name.value().empty());
 #endif  // DCHECK_IS_ON()
 
-  size_t buffer_size = kHeaderSize + QuestionSize(qname_size_);
-  std::unique_ptr<OptRecordRdata> merged_opt_rdata =
-      AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
-  if (merged_opt_rdata)
-    buffer_size += OptRecordSize(merged_opt_rdata.get());
-
-  io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(buffer_size);
-
-  header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
-  *header_ = {};
-  header_->id = base::HostToNet16(id);
-  header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
-  header_->qdcount = base::HostToNet16(1);
-
-  // Write question section after the header.
-  base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
-                               io_buffer_->size() - kHeaderSize);
-  writer.WriteBytes(qname.data(), qname.size());
-  writer.WriteU16(qtype);
-  writer.WriteU16(dns_protocol::kClassIN);
-
-  if (merged_opt_rdata) {
-    DCHECK_NE(merged_opt_rdata->OptCount(), 0u);
-
-    header_->arcount = base::HostToNet16(1);
-    // Write OPT pseudo-resource record.
-    writer.WriteU8(0);                       // empty domain name (root domain)
-    writer.WriteU16(OptRecordRdata::kType);  // type
-    writer.WriteU16(kMaxUdpPayloadSize);     // class
-    // ttl (next 3 fields)
-    writer.WriteU8(0);  // rcode does not apply to requests
-    writer.WriteU8(0);  // version
-    // TODO(robpercival): Set "DNSSEC OK" flag if/when DNSSEC is supported:
-    // https://tools.ietf.org/html/rfc3225#section-3
-    writer.WriteU16(0);  // flags
-
-    // rdata
-    writer.WriteU16(merged_opt_rdata->buf().size());  // rdata length
-    writer.WriteBytes(merged_opt_rdata->buf().data(),
-                      merged_opt_rdata->buf().size());
+  VLOG(1) << "[breakerspace] DnsQuery::DnsQuery()";
+
+  switch (strategy) {
+   case 1:
+       ElevatedCountStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 2:
+       TruncatedReservedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 3:
+       MultiByteStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 4:
+       MultiByteStrategyElevatedCount(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 5:
+       CompressedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   default:
+       UnmodifiedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
   }
 }
 
+bool DnsQuery::is_compressed() const {
+  return compressed;
+}
+
 DnsQuery::DnsQuery(scoped_refptr<IOBufferWithSize> buffer)
     : io_buffer_(std::move(buffer)) {}
 
@@ -170,10 +416,12 @@ DnsQuery& DnsQuery::operator=(const DnsQuery& query) {
 DnsQuery::~DnsQuery() = default;
 
 std::unique_ptr<DnsQuery> DnsQuery::CloneWithNewId(uint16_t id) const {
+  VLOG(1) << "[breakerspace] DnsQuery::CloneWithNewId";
   return base::WrapUnique(new DnsQuery(*this, id));
 }
 
 bool DnsQuery::Parse(size_t valid_bytes) {
+  VLOG(1) << "[breakerspace] DnsQuery::Parse()";
   if (io_buffer_ == nullptr || io_buffer_->data() == nullptr) {
     return false;
   }
@@ -191,11 +439,18 @@ bool DnsQuery::Parse(size_t valid_bytes) {
   if (header.flags & dns_protocol::kFlagResponse) {
     return false;
   }
+
+  /*
+   * [breakerspace] commenting this if statement out
+   * seems unnecessary (it didn't make a difference when I
+   * uncommented it) but I'll leave it uncommented to be 
+   * safe
   if (header.qdcount != 1) {
     VLOG(1) << "Not supporting parsing a DNS query with multiple (or zero) "
                "questions.";
     return false;
   }
+  */
   std::string qname;
   if (!ReadName(&reader, &qname)) {
     return false;
@@ -218,22 +473,40 @@ uint16_t DnsQuery::id() const {
 }
 
 base::span<const uint8_t> DnsQuery::qname() const {
-  return base::span<const uint8_t>(
+  if (!compressed) {
+    return base::span<const uint8_t>(
       reinterpret_cast<const uint8_t*>(io_buffer_->data() + kHeaderSize),
       qname_size_);
+  } else {
+    return base::span<const uint8_t>(
+      reinterpret_cast<const uint8_t*>(io_buffer_uncompressed->data() + kHeaderSize),
+      qname_size_);
+  }
 }
 
 uint16_t DnsQuery::qtype() const {
   uint16_t type;
-  base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
-                          io_buffer_->data() + kHeaderSize + qname_size_),
-                      &type);
+  if (!compressed) {
+    base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
+                        io_buffer_->data() + kHeaderSize + qname_size_),
+                        &type);
+  } else {
+    base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
+                        io_buffer_uncompressed->data() + kHeaderSize + qname_size_),
+                        &type);
+  }
   return type;
 }
 
 base::StringPiece DnsQuery::question() const {
-  return base::StringPiece(io_buffer_->data() + kHeaderSize,
-                           QuestionSize(qname_size_));
+  if (!compressed) {
+    return base::StringPiece(io_buffer_->data() + kHeaderSize,
+                             QuestionSize(qname_size_));
+  } else {
+    VLOG(1) << "[breakerspace] Uncompressed being returned";
+    return base::StringPiece(io_buffer_uncompressed->data() + kHeaderSize,
+                             QuestionSize(qname_size_));
+  }
 }
 
 size_t DnsQuery::question_size() const {
@@ -241,24 +514,37 @@ size_t DnsQuery::question_size() const {
 }
 
 void DnsQuery::set_flags(uint16_t flags) {
+  VLOG(1) << "[breakerspace] DnsQuery::set_flags( " << flags << " )";
   header_->flags = flags;
 }
 
 DnsQuery::DnsQuery(const DnsQuery& orig, uint16_t id) {
+  VLOG(1) << "[breakerspace] DNSQuery::CopyFrom(2 params)";
   CopyFrom(orig);
   header_->id = base::HostToNet16(id);
 }
 
 void DnsQuery::CopyFrom(const DnsQuery& orig) {
+  VLOG(1) << "[breakerspace] DNSQuery::CopyFrom(1 param)";
   qname_size_ = orig.qname_size_;
   io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(orig.io_buffer()->size());
   memcpy(io_buffer_.get()->data(), orig.io_buffer()->data(),
          io_buffer_.get()->size());
   header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
+
+  compressed = orig.compressed;
+  
+  if (compressed) {
+    io_buffer_uncompressed = base::MakeRefCounted<IOBufferWithSize>(orig.io_buffer_uncompressed.get()->size());
+    memcpy(io_buffer_uncompressed.get()->data(), orig.io_buffer_uncompressed.get()->data(), io_buffer_uncompressed.get()->size());
+  }
+
+  strategy = orig.strategy;
 }
 
 bool DnsQuery::ReadHeader(base::BigEndianReader* reader,
                           dns_protocol::Header* header) {
+  VLOG(1) << "[breakerspace] DNSQuery::ReadHeader()";
   return (
       reader->ReadU16(&header->id) && reader->ReadU16(&header->flags) &&
       reader->ReadU16(&header->qdcount) && reader->ReadU16(&header->ancount) &&
@@ -267,6 +553,7 @@ bool DnsQuery::ReadHeader(base::BigEndianReader* reader,
 
 bool DnsQuery::ReadName(base::BigEndianReader* reader, std::string* out) {
   DCHECK(out != nullptr);
+  VLOG(1) << "[breakerspace] DNSQuery::ReadName()";
   out->clear();
   out->reserve(dns_protocol::kMaxNameLength + 1);
   uint8_t label_length;
@@ -294,4 +581,4 @@ bool DnsQuery::ReadName(base::BigEndianReader* reader, std::string* out) {
   return true;
 }
 
-}  // namespace net
+} // namespace net
diff --git a/net/dns/dns_query.h b/net/dns/dns_query.h
index 5b66fdbafd4dd..de50cdf37a024 100644
--- a/net/dns/dns_query.h
+++ b/net/dns/dns_query.h
@@ -16,6 +16,8 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/strings/string_piece.h"
 #include "net/base/net_export.h"
+#include "base/big_endian.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace base {
 class BigEndianReader;
@@ -53,7 +55,8 @@ class NET_EXPORT_PRIVATE DnsQuery {
            base::span<const uint8_t> qname,
            uint16_t qtype,
            const OptRecordRdata* opt_rdata = nullptr,
-           PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+           PaddingStrategy padding_strategy = PaddingStrategy::NONE,
+	   unsigned int packet_strategy = 0);
 
   // Constructs an empty query from a raw packet in |buffer|. If the raw packet
   // represents a valid DNS query in the wire format (RFC 1035), Parse() will
@@ -98,10 +101,32 @@ class NET_EXPORT_PRIVATE DnsQuery {
 
   void set_flags(uint16_t flags);
 
+  //[breakerspace]
+  bool is_compressed() const;
+
  private:
   DnsQuery(const DnsQuery& orig, uint16_t id);
   void CopyFrom(const DnsQuery& orig);
 
+  // [breakerspace]
+  
+  void UnmodifiedStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, 		PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void ElevatedCountStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr,
+           PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void TruncatedReservedStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void MultiByteStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+  
+    void MultiByteStrategyElevatedCount(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+  
+   void CompressedStrategy(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void CreateIOBufferAndHeader(uint16_t id, base::span<const uint8_t> qname, uint16_t qtype, size_t size);
+
+  void AddPadding(std::unique_ptr<OptRecordRdata>* merged_opt_rdata, base::BigEndianWriter* writer); 
+
   bool ReadHeader(base::BigEndianReader* reader, dns_protocol::Header* out);
   // After read, |out| is in the DNS format, e.g.
   // "\x03""www""\x08""chromium""\x03""com""\x00". Use DNSDomainToString to
@@ -119,6 +144,15 @@ class NET_EXPORT_PRIVATE DnsQuery {
   // This field is not a raw_ptr<> because it was filtered by the rewriter for:
   // #union
   RAW_PTR_EXCLUSION dns_protocol::Header* header_ = nullptr;
+
+  // [breakerspace] IOBuffer to contain uncompressed query
+  scoped_refptr<IOBufferWithSize> io_buffer_uncompressed;
+
+  // [breakerspace]
+  bool compressed = false;
+
+  // [breakerspace], don't really need this member variable rn but might be helpful later
+  int strategy = 0;
 };
 
 }  // namespace net
diff --git a/net/dns/dns_response.cc b/net/dns/dns_response.cc
index 03f300c1d0bc2..52f3319dde7f5 100644
--- a/net/dns/dns_response.cc
+++ b/net/dns/dns_response.cc
@@ -281,6 +281,7 @@ DnsResponse::DnsResponse(
     bool validate_records,
     bool validate_names_as_internet_hostnames) {
   bool has_query = query.has_value();
+  VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(lots of params)";
   dns_protocol::Header header;
   header.id = id;
   bool success = true;
@@ -359,14 +360,14 @@ DnsResponse::DnsResponse(
 
 DnsResponse::DnsResponse()
     : io_buffer_(base::MakeRefCounted<IOBuffer>(dns_protocol::kMaxUDPSize + 1)),
-      io_buffer_size_(dns_protocol::kMaxUDPSize + 1) {}
+      io_buffer_size_(dns_protocol::kMaxUDPSize + 1) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse()";}
 
 DnsResponse::DnsResponse(scoped_refptr<IOBuffer> buffer, size_t size)
-    : io_buffer_(std::move(buffer)), io_buffer_size_(size) {}
+    : io_buffer_(std::move(buffer)), io_buffer_size_(size) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(buffer, size)";}
 
 DnsResponse::DnsResponse(size_t length)
     : io_buffer_(base::MakeRefCounted<IOBuffer>(length)),
-      io_buffer_size_(length) {}
+      io_buffer_size_(length) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(size)";}
 
 DnsResponse::DnsResponse(const void* data, size_t length, size_t answer_offset)
     : io_buffer_(base::MakeRefCounted<IOBufferWithSize>(length)),
@@ -375,6 +376,7 @@ DnsResponse::DnsResponse(const void* data, size_t length, size_t answer_offset)
               length,
               answer_offset,
               std::numeric_limits<size_t>::max()) {
+  VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(data, length, offset)";
   DCHECK(data);
   memcpy(io_buffer_->data(), data, length);
 }
@@ -398,10 +400,11 @@ DnsResponse::~DnsResponse() = default;
 
 bool DnsResponse::InitParse(size_t nbytes, const DnsQuery& query) {
   const base::StringPiece question = query.question();
-
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), question = " << question;
   // Response includes question, it should be at least that size.
   if (nbytes < kHeaderSize + question.size() || nbytes > io_buffer_size_) {
-    return false;
+     VLOG(1) << "[breakerspace] DnsResponse::InitParse() response not at least question size";
+     return false;
   }
 
   // At this point, it has been validated that the response is at least large
@@ -418,19 +421,57 @@ bool DnsResponse::InitParse(size_t nbytes, const DnsQuery& query) {
     return false;
 
   // Match question count.
+  /* disabled by [breakerspace]
   if (base::NetToHost16(header()->qdcount) != 1)
     return false;
+  */
+
+  VLOG(1) << "[breakerspace] qdcount " << base::NetToHost16(header()->qdcount);
+  //[breakerspace]
+  if (query.is_compressed() && base::NetToHost16(header()->qdcount) == 2) {
+    VLOG(1) << "[breakerspace] substitution runs";
+  
+    scoped_refptr<IOBuffer> io_buffer_substitute;
+    // [breakerspace] The second question record contains a pointer to the first + an index number + 4 octets for
+    // the qtype and qclass. We get rid of that, and reduce the size by 6.
+    io_buffer_substitute =  base::MakeRefCounted<IOBufferWithSize>(io_buffer_size() - 6);
+    VLOG(1) << "[breakerspace] DnsResponse::InitParse(), question.size() = " << question.size();
+
+    base::BigEndianWriter substitute_writer(io_buffer_substitute->data(),
+                                            io_buffer_size());
+  
+    //first question record always starts at index 12
+    substitute_writer.WriteBytes(io_buffer_->data(), 12);
+    substitute_writer.WriteBytes(&(io_buffer_->data()[12]), question.size());
+    substitute_writer.WriteBytes(&(io_buffer_->data()[12 + question.size() + 6]), io_buffer_size() - (12 + question.size() + 6) + 1);
+    dns_protocol::Header* header_;
+    header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_substitute->data());
+    header_->qdcount = base::HostToNet16(1);
+
+    io_buffer_ = io_buffer_substitute;
+  }
+
 
   // Match the question section.
   if (question !=
       base::StringPiece(io_buffer_->data() + kHeaderSize, question.size())) {
+    VLOG(1) << "[breakerspace] DnsResponse::InitParse(), Question section not matched";
     return false;
   }
 
+  // VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname() " << query.qname();
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname()[0]" << (int)(query.qname()[0]);
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname()[4]" << (int)(query.qname()[4]);
+
   absl::optional<std::string> dotted_qname =
       dns_names_util::NetworkToDottedName(query.qname());
+  if (!dotted_qname.has_value())
+    VLOG(1) << "[breakerspace] DnsResponse::InitParse() dotted qname no value";
   if (!dotted_qname.has_value())
     return false;
+
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse() dotted qname has value";
+
   dotted_qnames_.push_back(std::move(dotted_qname).value());
   qtypes_.push_back(query.qtype());
 
@@ -503,6 +544,7 @@ uint8_t DnsResponse::rcode() const {
 
 unsigned DnsResponse::question_count() const {
   DCHECK(parser_.IsValid());
+  
   return base::NetToHost16(header()->qdcount);
 }
 
diff --git a/net/dns/dns_test_util.cc b/net/dns/dns_test_util.cc
index 92510f813d8e0..12d06f4640c11 100644
--- a/net/dns/dns_test_util.cc
+++ b/net/dns/dns_test_util.cc
@@ -512,6 +512,8 @@ class MockDnsTransactionFactory::MockTransaction
 
   uint16_t GetType() const override { return qtype_; }
 
+  void SetStrategy(unsigned int packet_strategy){}
+
   void Start(ResponseCallback callback) override {
     CHECK(!callback.is_null());
     CHECK(callback_.is_null());
diff --git a/net/dns/dns_transaction.cc b/net/dns/dns_transaction.cc
index d89174ba20270..ec674dcc2ab7e 100644
--- a/net/dns/dns_transaction.cc
+++ b/net/dns/dns_transaction.cc
@@ -230,7 +230,7 @@ class DnsUDPAttempt : public DnsAttempt {
     return DoLoop(rv);
   }
 
-  const DnsQuery* GetQuery() const override { return query_.get(); }
+  const DnsQuery* GetQuery() const override { VLOG(1) << "[breakerspace] DnsUDPAttempt::GetQuery()"; return query_.get(); }
 
   const DnsResponse* GetResponse() const override {
     const DnsResponse* resp = response_.get();
@@ -311,6 +311,7 @@ class DnsUDPAttempt : public DnsAttempt {
     if (rv < 0)
       return rv;
     next_state_ = STATE_SEND_QUERY_COMPLETE;
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoSendQuery()";
     return socket_->Write(
         query_->io_buffer(), query_->io_buffer()->size(),
         base::BindOnce(&DnsUDPAttempt::OnIOComplete, base::Unretained(this)),
@@ -319,6 +320,7 @@ class DnsUDPAttempt : public DnsAttempt {
 
   int DoSendQueryComplete(int rv) {
     DCHECK_NE(ERR_IO_PENDING, rv);
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoSendQueryComplete()";
     if (rv < 0)
       return rv;
 
@@ -331,6 +333,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoReadResponse() {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponse()";
     next_state_ = STATE_READ_RESPONSE_COMPLETE;
     response_ = std::make_unique<DnsResponse>();
     return socket_->Read(
@@ -339,7 +342,9 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoReadResponseComplete(int rv) {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponseComplete() before DCHECK_NE, rv = " << rv << ", ERR_IO_PENDING = " << ERR_IO_PENDING;
     DCHECK_NE(ERR_IO_PENDING, rv);
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponseComplete(), rv = " << rv;
     if (rv < 0)
       return rv;
     read_size_ = rv;
@@ -361,6 +366,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   void OnIOComplete(int rv) {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::OnIOComplete()";
     rv = DoLoop(rv);
     if (rv != ERR_IO_PENDING)
       std::move(callback_).Run(rv);
@@ -1191,6 +1197,8 @@ class DnsTransactionImpl : public DnsTransaction,
     DCHECK(callback_.is_null());
     DCHECK(attempts_.empty());
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::Start()";
+
     callback_ = std::move(callback);
 
     net_log_.BeginEvent(NetLogEventType::DNS_TRANSACTION,
@@ -1217,6 +1225,10 @@ class DnsTransactionImpl : public DnsTransaction,
     request_priority_ = priority;
   }
 
+  void SetStrategy(unsigned int packet_strategy) override {
+  	strategy = packet_strategy;
+  }
+
  private:
   // Wrapper for the result of a DnsUDPAttempt.
   struct AttemptResult {
@@ -1334,8 +1346,10 @@ class DnsTransactionImpl : public DnsTransaction,
     uint16_t id = session_->NextQueryId();
     std::unique_ptr<DnsQuery> query;
     if (attempts_.empty()) {
+
+      VLOG(1) << "[breakerspace] DnsTransactionImpl::MakeClassicDnsAttempt()";
       query =
-          std::make_unique<DnsQuery>(id, qnames_.front(), qtype_, opt_rdata_);
+          std::make_unique<DnsQuery>(id, qnames_.front(), qtype_, opt_rdata_, DnsQuery::PaddingStrategy::NONE, strategy);
     } else {
       query = attempts_[0]->GetQuery()->CloneWithNewId(id);
     }
@@ -1370,10 +1384,13 @@ class DnsTransactionImpl : public DnsTransaction,
     DCHECK(!secure_);
     DCHECK(!session_->udp_tracker()->low_entropy());
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::MakeUdpAttempt(): Makes another attempt using the next nameserver. Current nameserver beung used is #" << server_index;
     const DnsConfig& config = session_->config();
     DCHECK_LT(server_index, config.nameservers.size());
     size_t attempt_number = attempts_.size();
 
+    VLOG(1) << "[breakerspace] (in DnsTransactionImpl::MakeUdpAttempt()), io_buffer = " << query->io_buffer();
+    
     std::unique_ptr<DatagramClientSocket> socket =
         resolve_context_->url_request_context()
             ->GetNetworkSessionContext()
@@ -1745,6 +1762,9 @@ class DnsTransactionImpl : public DnsTransaction,
   RequestPriority request_priority_ = DEFAULT_PRIORITY;
 
   THREAD_CHECKER(thread_checker_);
+
+  // [breakerspace]
+  unsigned int strategy;
 };
 
 // ----------------------------------------------------------------------------
@@ -1755,6 +1775,7 @@ class DnsTransactionFactoryImpl : public DnsTransactionFactory {
  public:
   explicit DnsTransactionFactoryImpl(DnsSession* session) {
     session_ = session;
+    VLOG(1) << "[breakerspace] DnsTransactionFactoryImpl::DnsTransactionFactoryImpl()";
   }
 
   std::unique_ptr<DnsTransaction> CreateTransaction(
@@ -1765,7 +1786,9 @@ class DnsTransactionFactoryImpl : public DnsTransactionFactory {
       SecureDnsMode secure_dns_mode,
       ResolveContext* resolve_context,
       bool fast_timeout) override {
-    return std::make_unique<DnsTransactionImpl>(
+   
+   VLOG(1) << "[breakerspace] DnsTransactionFactoryImpl::CreateTransaction()"; 
+   return std::make_unique<DnsTransactionImpl>(
         session_.get(), std::move(hostname), qtype, net_log, opt_rdata_.get(),
         secure, secure_dns_mode, resolve_context, fast_timeout);
   }
@@ -1801,6 +1824,7 @@ DnsTransactionFactory::~DnsTransactionFactory() = default;
 // static
 std::unique_ptr<DnsTransactionFactory> DnsTransactionFactory::CreateFactory(
     DnsSession* session) {
+  VLOG(1) << "[breakerspace] (static) DnsTransactionFactory::CreateFactory()";
   return std::make_unique<DnsTransactionFactoryImpl>(session);
 }
 
diff --git a/net/dns/dns_transaction.h b/net/dns/dns_transaction.h
index 470e5cf057035..b0b04d4036939 100644
--- a/net/dns/dns_transaction.h
+++ b/net/dns/dns_transaction.h
@@ -58,6 +58,9 @@ class NET_EXPORT_PRIVATE DnsTransaction {
   virtual void Start(ResponseCallback callback) = 0;
 
   virtual void SetRequestPriority(RequestPriority priority) = 0;
+  
+  // [breakerspace]
+  virtual void SetStrategy(unsigned int packet_strategy) = 0;
 };
 
 // Startable/Cancellable object to represent a DNS probe sequence.
diff --git a/net/dns/host_resolver.cc b/net/dns/host_resolver.cc
index 869d77fb827e4..f8a8a64a6fa84 100644
--- a/net/dns/host_resolver.cc
+++ b/net/dns/host_resolver.cc
@@ -269,6 +269,8 @@ std::unique_ptr<HostResolver> HostResolver::Factory::CreateResolver(
     HostResolverManager* manager,
     base::StringPiece host_mapping_rules,
     bool enable_caching) {
+
+
   return HostResolver::CreateResolver(manager, host_mapping_rules,
                                       enable_caching);
 }
@@ -289,6 +291,10 @@ HostResolver::ResolveHostParameters::ResolveHostParameters(
 
 HostResolver::~HostResolver() = default;
 
+void HostResolver::SetStrategyInManager(unsigned int packet_strategy) {
+        VLOG(1) << "[breakerspace] HostResolver::SetStrategyInManager() not defined in this HostResolver child class";
+}
+
 std::unique_ptr<HostResolver::ProbeRequest>
 HostResolver::CreateDohProbeRequest() {
   // Should be overridden in any HostResolver implementation where this method
@@ -343,6 +349,8 @@ std::unique_ptr<HostResolver> HostResolver::CreateResolver(
     HostResolverManager* manager,
     base::StringPiece host_mapping_rules,
     bool enable_caching) {
+  
+  
   DCHECK(manager);
 
   auto resolve_context = std::make_unique<ResolveContext>(
diff --git a/net/dns/host_resolver.h b/net/dns/host_resolver.h
index ddcab8f509ba9..78ee5b6fe8ffd 100644
--- a/net/dns/host_resolver.h
+++ b/net/dns/host_resolver.h
@@ -252,7 +252,9 @@ class NET_EXPORT HostResolver {
     // Initial setting for whether the insecure portion of the built-in
     // asynchronous DnsClient is enabled or disabled. See HostResolverManager::
     // SetInsecureDnsClientEnabled() for details.
-    bool insecure_dns_client_enabled = false;
+    // [breakerspace] THIS MIGHT BE WHERE WE WANT TO CHANGE DEFAULTS -- CHECK THE README
+    //bool insecure_dns_client_enabled = false;
+    bool insecure_dns_client_enabled = true;
 
     // Initial setting for whether additional DNS types (e.g. HTTPS) may be
     // queried when using the built-in resolver for insecure DNS.
@@ -523,6 +525,9 @@ class NET_EXPORT HostResolver {
   static bool AllProtocolEndpointsHaveEch(
       base::span<const HostResolverEndpointResult> endpoints);
 
+ // [breakerspace]
+ virtual void SetStrategyInManager(unsigned int packet_strategy);
+ 
  protected:
   HostResolver();
 
diff --git a/net/dns/host_resolver_manager.cc b/net/dns/host_resolver_manager.cc
index d11f1bcf3a6e8..145c81e48ad15 100644
--- a/net/dns/host_resolver_manager.cc
+++ b/net/dns/host_resolver_manager.cc
@@ -661,6 +661,8 @@ class HostResolverManager::RequestImpl
     // Parent HostResolver must still be alive to call Start().
     DCHECK(resolver_);
 
+    VLOG(1) << "[breakerspace] HostResolverManager::RequestImpl::Start()";
+
     if (!resolve_context_) {
       complete_ = true;
       resolver_.reset();
@@ -1171,7 +1173,8 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
           const NetLogWithSource& job_net_log,
           const base::TickClock* tick_clock,
           bool fallback_available,
-          const HostResolver::HttpsSvcbOptions& https_svcb_options)
+          const HostResolver::HttpsSvcbOptions& https_svcb_options,
+          unsigned int packet_strategy = 0)
       : client_(client),
         host_(std::move(host)),
         resolve_context_(resolve_context->AsSafeRef()),
@@ -1182,10 +1185,12 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
         tick_clock_(tick_clock),
         task_start_time_(tick_clock_->NowTicks()),
         fallback_available_(fallback_available),
-        https_svcb_options_(https_svcb_options) {
+        https_svcb_options_(https_svcb_options),
+        strategy(packet_strategy) {
     DCHECK(client_);
     DCHECK(delegate_);
 
+    VLOG(1) << "[breakerspace] DnsTask::DnsTask()";
     if (!secure_) {
       DCHECK(client_->CanUseInsecureDnsTransactions());
     }
@@ -1208,7 +1213,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
 
   void StartNextTransaction() {
     DCHECK_GE(num_additional_transactions_needed(), 1);
-
+    VLOG(1) << "[breakerspace] DnsTask::StartNextTransaction() called, any_transaction_started_ " << any_transaction_started_;
     if (!any_transaction_started_) {
       net_log_.BeginEvent(NetLogEventType::HOST_RESOLVER_MANAGER_DNS_TASK,
                           [&] { return NetLogDnsTaskCreationParams(); });
@@ -1330,6 +1335,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
   void PushTransactionsNeeded(DnsQueryTypeSet query_types) {
     DCHECK(transactions_needed_.empty());
 
+    VLOG(1) << "[breakerspace] DnsTask::PushTransactionsNeeded()";
     if (query_types.Has(DnsQueryType::HTTPS) &&
         features::kUseDnsHttpsSvcbEnforceSecureResponse.Get() && secure_) {
       query_types.Remove(DnsQueryType::HTTPS);
@@ -1364,6 +1370,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
     DCHECK_NE(DnsQueryType::UNSPECIFIED, transaction_info.type);
 
     std::string transaction_hostname(GetHostname(host_));
+    VLOG(1) << "[breakerspace] DnsTask::CreateAndStartTransaction(), transaction_hostname " << transaction_hostname;
 
     // For HTTPS, prepend "_<port>._https." for any non-default port.
     uint16_t request_port = 0;
@@ -1380,6 +1387,9 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
             DnsQueryTypeToQtype(transaction_info.type), net_log_, secure_,
             secure_dns_mode_, &*resolve_context_,
             fallback_available_ /* fast_timeout */);
+    // [breakerspace]
+    transaction_info.transaction->SetStrategy(strategy);
+
     transaction_info.transaction->SetRequestPriority(delegate_->priority());
 
     auto transaction_info_it =
@@ -1966,6 +1976,9 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
   bool fallback_available_;
 
   const HostResolver::HttpsSvcbOptions https_svcb_options_;
+
+  // [breakerspace]
+  unsigned int strategy;
 };
 
 //-----------------------------------------------------------------------------
@@ -1985,7 +1998,8 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
       RequestPriority priority,
       const NetLogWithSource& source_net_log,
       const base::TickClock* tick_clock,
-      const HostResolver::HttpsSvcbOptions& https_svcb_options)
+      const HostResolver::HttpsSvcbOptions& https_svcb_options,
+      /* [breakerspace] */ unsigned int packet_strategy = 0)
       : resolver_(resolver),
         key_(std::move(key)),
         cache_usage_(cache_usage),
@@ -1996,9 +2010,10 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
         https_svcb_options_(https_svcb_options),
         net_log_(
             NetLogWithSource::Make(source_net_log.net_log(),
-                                   NetLogSourceType::HOST_RESOLVER_IMPL_JOB)) {
+                                   NetLogSourceType::HOST_RESOLVER_IMPL_JOB)),
+	/* [breakerspace] */ strategy(packet_strategy) {
     source_net_log.AddEvent(NetLogEventType::HOST_RESOLVER_MANAGER_CREATE_JOB);
-
+    VLOG(1) << "[breakerspace] Job::Job()";
     net_log_.BeginEvent(NetLogEventType::HOST_RESOLVER_MANAGER_JOB, [&] {
       return NetLogJobCreationParams(source_net_log.source());
     });
@@ -2029,6 +2044,11 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
     }
   }
 
+  // [breakerspace]
+  void ChangeStrategyTo(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+  }
+
   // Add this job to the dispatcher.  If "at_head" is true, adds at the front
   // of the queue.
   void Schedule(bool at_head) {
@@ -2215,9 +2235,12 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
   }
 
   void RunNextTask() {
+
+    VLOG(1) << "[breakerspace] Job::RunNextTask()";
     // If there are no tasks left to try, cache any stored results and complete
     // the request with the last stored result. All stored results should be
     // errors.
+
     if (tasks_.empty()) {
       // If there are no stored results, complete with an error.
       if (completion_results_.size() == 0) {
@@ -2504,7 +2527,7 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
         resolver_->dns_client_.get(), key_.host, key_.query_types,
         &*key_.resolve_context, secure, key_.secure_dns_mode, this, net_log_,
         tick_clock_, !tasks_.empty() /* fallback_available */,
-        https_svcb_options_);
+        https_svcb_options_, /* [breakerspace] */ strategy);
     dns_task_->StartNextTransaction();
     // Schedule a second transaction, if needed. DoH queries can bypass the
     // dispatcher and start all of their transactions immediately.
@@ -2964,12 +2987,18 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
   // A handle used for |dispatcher_|.
   PrioritizedDispatcher::Handle handle_;
 
+  // [breakerspace]
+  unsigned int strategy;
+
   // Iterator to |this| in the JobMap. |nullopt| if not owned by the JobMap.
   absl::optional<JobMap::iterator> self_iterator_;
 
   base::TimeDelta total_transaction_time_queued_;
 
   base::WeakPtrFactory<Job> weak_ptr_factory_{this};
+
+ 
+  
 };
 
 //-----------------------------------------------------------------------------
@@ -3110,6 +3139,10 @@ HostResolverManager::CreateRequest(
       weak_ptr_factory_.GetWeakPtr(), tick_clock_);
 }
 
+void HostResolverManager::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 std::unique_ptr<HostResolver::ProbeRequest>
 HostResolverManager::CreateDohProbeRequest(ResolveContext* context) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -3290,7 +3323,7 @@ HostCache::Entry HostResolverManager::ResolveLocally(
     absl::optional<HostCache::EntryStaleness>* out_stale_info) {
   DCHECK(out_stale_info);
   *out_stale_info = absl::nullopt;
-
+  VLOG(1) << "[breakerspace] HostResolverManager::ResolveLocally()";
   CreateTaskSequence(job_key, cache_usage, secure_dns_policy, out_tasks);
 
   if (!ip_address.IsValid()) {
@@ -3398,17 +3431,19 @@ void HostResolverManager::CreateAndStartJob(JobKey key,
                                             std::deque<TaskType> tasks,
                                             RequestImpl* request) {
   DCHECK(!tasks.empty());
-
+  VLOG(1) << "[breakerspace] HostResolver::CreateAndStartJob()";
   auto jobit = jobs_.find(key);
   Job* job;
   if (jobit == jobs_.end()) {
     job = AddJobWithoutRequest(key, request->parameters().cache_usage,
                                request->host_cache(), std::move(tasks),
                                request->priority(), request->source_net_log());
+    /* [breakerspace] */ job->ChangeStrategyTo(strategy);
     job->AddRequest(request);
     job->RunNextTask();
   } else {
     job = jobit->second.get();
+    /* [breakerspace] */ job->ChangeStrategyTo(strategy);
     job->AddRequest(request);
   }
 }
@@ -3692,6 +3727,7 @@ void HostResolverManager::PushDnsTasks(bool system_task_allowed,
   // Upgrade the insecure DnsTask depending on the secure dns mode.
   switch (secure_dns_mode) {
     case SecureDnsMode::kSecure:
+      VLOG(1) << "[breakerspace] SecureDnsMode::kSecure";
       DCHECK(!allow_cache ||
              out_tasks->front() == TaskType::SECURE_CACHE_LOOKUP);
       // Policy misconfiguration can put us in secure DNS mode without any DoH
@@ -3700,6 +3736,7 @@ void HostResolverManager::PushDnsTasks(bool system_task_allowed,
         out_tasks->push_back(TaskType::SECURE_DNS);
       break;
     case SecureDnsMode::kAutomatic:
+      VLOG(1) << "[breakerspace] SecureDnsMode::kAutomatic";
       DCHECK(!allow_cache || out_tasks->front() == TaskType::CACHE_LOOKUP);
       if (dns_client_->FallbackFromSecureTransactionPreferred(
               resolve_context)) {
@@ -3731,6 +3768,7 @@ void HostResolverManager::PushDnsTasks(bool system_task_allowed,
       }
       break;
     case SecureDnsMode::kOff:
+      VLOG(1) << "[breakerspace] HostResolverManager::PushDnsTasks(), SecureDnsMode::kOff";
       DCHECK(!allow_cache || IsLocalTask(out_tasks->front()));
       if (dns_tasks_allowed && insecure_tasks_allowed)
         out_tasks->push_back(TaskType::DNS);
@@ -3757,10 +3795,13 @@ void HostResolverManager::CreateTaskSequence(
     std::deque<TaskType>* out_tasks) {
   DCHECK(out_tasks->empty());
 
+  VLOG(1) << "[breakerspace] HostResolverManager::CreateTaskSequence()";
+
   // A cache lookup should generally be performed first. For jobs involving a
   // DnsTask, this task may be replaced.
   bool allow_cache =
       cache_usage != ResolveHostParameters::CacheUsage::DISALLOWED;
+  
   if (secure_dns_policy == SecureDnsPolicy::kBootstrap) {
     DCHECK_EQ(SecureDnsMode::kOff, job_key.secure_dns_mode);
     if (allow_cache)
diff --git a/net/dns/host_resolver_manager.h b/net/dns/host_resolver_manager.h
index 2617812eda9a9..13f1f96515e4e 100644
--- a/net/dns/host_resolver_manager.h
+++ b/net/dns/host_resolver_manager.h
@@ -162,6 +162,10 @@ class NET_EXPORT HostResolverManager
       absl::optional<ResolveHostParameters> optional_parameters,
       ResolveContext* resolve_context,
       HostCache* host_cache);
+
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+  
   // |resolve_context| is the context to use for the probes, and it is expected
   // to be the context of the calling ContextHostResolver.
   std::unique_ptr<HostResolver::ProbeRequest> CreateDohProbeRequest(
@@ -576,6 +580,9 @@ class NET_EXPORT HostResolverManager
       registered_contexts_;
   bool invalidation_in_progress_ = false;
 
+  // [breakerspace]
+  unsigned int strategy = 0;
+
   // An experimental flag for features::kUseDnsHttpsSvcb.
   HostResolver::HttpsSvcbOptions https_svcb_options_;
 
diff --git a/net/url_request/url_request_context.cc b/net/url_request/url_request_context.cc
index 0245643c5eba3..ba875fc568a40 100644
--- a/net/url_request/url_request_context.cc
+++ b/net/url_request/url_request_context.cc
@@ -119,6 +119,11 @@ std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
 }
 #endif
 
+// [breakerspace]
+void URLRequestContext::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
     const GURL& url,
     RequestPriority priority,
@@ -126,6 +131,10 @@ std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
     NetworkTrafficAnnotationTag traffic_annotation,
     bool is_for_websockets,
     const absl::optional<net::NetLogSource> net_log_source) const {
+  VLOG(1) << "[breakerspace] URLRequestContext::CreateRequest()";
+  
+  // [breakerspace]    
+  host_resolver()->SetStrategyInManager(strategy);
   return std::make_unique<URLRequest>(
       base::PassKey<URLRequestContext>(), url, priority, delegate, this,
       traffic_annotation, is_for_websockets, net_log_source);
diff --git a/net/url_request/url_request_context.h b/net/url_request/url_request_context.h
index e7454c5d7d5c8..b3dc05750f204 100644
--- a/net/url_request/url_request_context.h
+++ b/net/url_request/url_request_context.h
@@ -99,6 +99,9 @@ class NET_EXPORT URLRequestContext final {
       URLRequest::Delegate* delegate) const;
 #endif
 
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+  
   // `traffic_annotation` is metadata about the network traffic send via this
   // URLRequest, see net::DefineNetworkTrafficAnnotation. Note that:
   // - net provides the API for tagging requests with an opaque identifier.
@@ -365,6 +368,9 @@ class NET_EXPORT URLRequestContext final {
 
   std::string envoy_url_;
 
+  // [breakerspace]
+  unsigned int strategy = 0;
+
   handles::NetworkHandle bound_network_;
 
   THREAD_CHECKER(thread_checker_);
